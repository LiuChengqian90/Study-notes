## Python核心编程（第二版）

### 第2章 Python 基础

Python交互式解释器中存在主提示符( >>> )和次提示符( ... )。主提示符是解释器告诉你它在等待你输入下一个语句，次提示符告诉你解释器正在等待你输入当前语句的其它部分。

Python 有两种主要的方式来完成需要的要求：语句和表达式（函数、算术表达式等）。语句使用关键字来组成命令，类似告诉解释器一个命令。而表达式没有关键字。它们可以是使用数学运算符构成的算术表达式，也可以是使用括号调用的函数。它们可以接受用户输入，也可以不接受用户输入，有些会有输出，有些则没有。

交互式解释器中，用 print 来显示变量的内容和仅用变量名显示是不同的，print语句调用str()函数显示对象，而交互式解释器则调用repr()函数来显示对象。repr 函数是 对象的字符串表示，而不仅仅是字符串本身。

下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。

Print 语句也支持将输出重定向到文件。这个特性是从Python2.0 开始新增的。符号 >> 用来重定向输出。

raw_input()内建函数读取标准输入，并将读取到的数据赋值给指定的变量。

Python 也使用 # 符号标示注释，从 # 开始，直到一行结束的内容都是注释。有一种叫做文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能。

Python 不支持 C 语言中的自增 1 和自减 1 运算符， 这是因为 + 和 － 也是单目运算符，Python 会将 --n 解释为-(-n) 从而得到 n , 同样 ++n 的结果也是 n。

Python 中字符串被定义为引号之间的字符集合。Python 支持使用成对的单引号或双引号，三引号（三个连续的单引号或者双引号）可以用来包含特殊字符。使用索引运算符( [ ] )和切片运算符( [ : ] )可以得到子字符串。字符串有其特有的索引规则：第一个字符的索引是 0，最后一个字符的索引是 -1。加号( + )用于字符串连接运算，星号( * )则用于字符串重复。

Python 中的 for 循环与传统的 for 循环（计数器循环）不太一样， 它更象 shell 脚本里的 foreach 迭代。Python 中的 for 接受可迭代对象（例如序列或迭代器）作为其参数，每次迭代其中一个元素。print 语句默认会给每一行添加一个换行
符。只要在 print 语句的最后添加一个逗号(,)， 就可以改变它这种行为。

enumerate()函数可同时得到集合的索引及元素。

函数中没有 return 语句， 会自动返回 None 对象。Python 是通过引用调用的。 这意味着函数内对参数的改变会影响到原始对象。不过事实上只有可变对象会受此影响， 对不可变对象来说， 它的行为类似按值调用。

在类中，所有名字开始和结束都有两个下划线的方法都是特殊方法。而self则是类实例自身的引用。其他语言通常使用一个名为 this 的标识符。

### 第3章 Python 基础

Python 语句中有一些基本规则和特殊字符：
​	井号(#)表示之后的字符为 Python 注释
​	换行 (\n) 是标准的行分隔符（通常一个语句一行）
​	反斜线 ( \ ) 继续上一行
​	分号 ( ; )将两个语句连接在一行中
​	冒号 ( : ) 将代码块的头和体分开
​	语句（代码块）用缩进块的方式体现
​	不同的缩进深度分隔不同的代码块
​	Python 文件以模块的形式组织

Python 语言中， 等号(=)是主要的赋值运算符。注意，赋值并不是直接将一个值赋给一个变量。在 Python 语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还是一个已经存在的，都是将该对象的引用（并不是值）赋值给变量。

Python 的赋值语句不会返回值。

增值赋值：x += 1

多重赋值：x = y = z = 1

“多元”赋值：x, y, z = 1, 2, 'a string'   ;   x, y = y, x

标识符是电脑语言中允许作为名字的有效字符串集合。其中，有一部分是关键字，构成语言的标识符。这样的标识符是不能做它用的标识符的，否则会引起语法错误（SyntaxError 异常）。Python 还有称为 built-in 标识符集合，虽然它们不是保留字，但是不推荐使用这些特别的名字。任何语言的关键字应该保持相对的稳定，但是因为 Python 是一门不断成长和进化的语言，关键字列表和 iskeyword()函数都放入了 keyword模块以便查阅。

除了关键字之外，Python 还有可以在任何一级代码使用的“内建”的名字集合，这些名字可以由解释器设置或使用。虽然 built-in 不是关键字，但是应该把它当作“系统保留字”，不做他用。然而，有些情况要求覆盖（也就是：重定义，替换）它们。Python 不支持重载标识符，所以任何时刻都只有一个名字绑定。built-in 是__builtins__模块的成员，在你的程序开始或在交互解释器中给出>>>提示之前，由解释器自动导入的。把它们看成适用在任何一级 Python 代码的全局变量。

Python 用下划线作为变量前缀和后缀指定特殊变量。

_xxx 不用'from module import *'导入
\__xxx__系统定义名字
__xxx 类中的私有变量名

Python 还提供了一个机制，可以通过__doc__特别变量，动态获得文档字串。在模块，类声明，或函数声明中第一个没有赋值的字符串可以用属性 obj.__doc__来进行访问，其中 obj是一个模块，类，或函数的名字。这在运行时刻也可以运行。

PEP 20 写的是 Python 之禅，你可以从那里开始你探索“Pythonic”真正含义的旅程。如果你不能上网，但想看到这篇诗句，那就从你的 Python 解释器输入 import this 然后回车。

所有的模块都有能力来执行代码。最高级别的 Python 语句－－也就是说， 那些没有缩进的代码行在模块被导入时就会执行， 不管是不是真的需要执行。由于有这样一个“特性”，比较安全的写代码的方式就是除了那些真正需要执行的代码以外， 几乎所有的功能代码都在函数当中。再说一遍， 通常只有主程序模块中有大量的顶级可执行代码，所有其它被导入的模块只应该有很少的顶级执行代码，所有的功能代码都应该封装在函数或类当中。

由于主程序代码无论模块是被导入还是被直接执行都会运行， 我们必须知道模块如何决定运行方向。一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码（否则就只能用拷贝粘贴那种非面向对象的愚蠢手段）。这种情况下，你只想访问那些位于其它应用程序中的代码，而不是想运行那个应用程序。因此一个问题出现了，“Python 是否有一种方法能在运行时检测该模块是被导入还是被直接执行呢？”  __name__ 系统变量就是正确答案。
如果模块是被导入， \__name__ 的值为模块名字
如果模块是被直接执行， \__name__ 的值为 '__main__'

Python 中变量名无需事先声明，也无需类型声明。Python 语言中，对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python 仍然是一种解释型语言。在创建---也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的应用会被赋值给左侧的变量。

Python 解释器承担了内存管理的复杂任务， 这大大简化了应用程序的编写。Python 使用了引用计数来追踪内存中的对象。

引用计数增加：当对象被创建并（将其引用）赋值给变量时，该对象的引用计数就被设置为 1。当同一个对象（的引用）又被赋值给其它变量时，或作为参数传递给函数， 方法或类实例时， 或者被赋值为一个窗口对象的成员时，该对象的一个新的引用，或者称作别名，就被创建（则该对象的引用计数自动加 1）。

引用计数减少：一个本地引用离开了其作用范围；对象的别名被显式的销毁（del）；对象的一个别名被赋值给其它的对象；；对象被从一个窗口对象中移除；窗口对象本身被销毁。

不再被使用的内存会被一种称为垃圾收集的机制释放。解释器跟踪对象的引用计数，垃圾收集器负责释放内存。垃圾收集器是一块独立代码， 它用来寻找引用计数为 0 的对象。它也负责检查那些虽然引用计数大于 0 但也应该被销毁的对象。 特定情形会导致循环引用。一个循环引用发生在当你有至少两个对象互相引用时， 也就是说所有的引用都消失时， 这
些引用仍然存在， 这说明只靠引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。 当一个对象的引用计数变为 0，解释器会暂停，释放掉这个对象和仅有这个对象可访问（可到达）的其它对象。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。

使用局部变量替换模块变量：类似 os.linesep 这样的名字需要解释器做两次查询： （1）查找 os 以确认它是一个模块，
（2）在这个模块中查找 linesep 变量。因为模块也是全局变量， 我们多消耗了系统资源。如果在一个函数中类似这样频繁使用一个属性，我们建议你为该属性取一个本地变量别名。 变量查找速度将会快很多－－在查找全局变量之前， 总是先查找本地变量。 这也是一个让你的程序跑的更快的技巧： 将经常用到的模块属性替换为一个本地引用。代码跑得更快，而也不用老是敲那么长的变量名了。

```python
#!/usr/bin/env Python

'readTextFile.py -- read and display text file'

# get filename
fname = raw_input('Enter filename: ')
print
# attempt to open file for reading
try:
	fobj = open(fname, 'r')
except IOError, e:
	print "*** file open error:", e
else:
# display contents to the screen
	for eachLine in fobj:
		print eachLine,
	fobj.close()
```

由于我们没有移除代表每行结束的行结束符，我们不得不抵制 print 语句自动生成的行结束符 －－通过在 print 语句的最后加一个逗号可以达到这一目的。

Python 代码风格指南（PEP8）, Python 快速参考和 Python 常见问答都是开发者很重要的“工具”。另外， 还有一些模块会帮助你成为一个优秀的 Python 程序员。
Debugger: pdb
Logger: logging
Profilers: profile, hotshot, cProfile

调试模块 pdb 允许你设置（条件）断点，代码逐行执行，检查堆栈。它还支持事后调试。
logging 模块是在 Python2.3 中新增的， 它定义了一些函数和类帮助你的程序实现灵活的日志系统。共有五级日志级别： 紧急， 错误，警告，信息和调试。
历史上，因为不同的人们为了满足不同的需求重复实现了很多性能测试器，Python 也有好几个性能测试模块。 最早的 Python profile 模块是 Python 写成的，用来测试函数的执行时间，及每次脚本执行的总时间，既没有特定函数的执行时间也没有被包含的子函数调用时间。在三个 profile 模块中，它是最老的也是最慢的，尽管如此， 它仍然可以提供一些有价值的性能信息。 hotshot 模块是在 Python2.2 中新增的，它的目标是取代 profile 模块， 它修复了profile 模块的一些错误， 因为它是用 C 语言写成，所以它有效的提高了性能。 注意 hotshot重点解决了性能测试过载的问题， 但却需要更多的时间来生成结果。Python2.5 版修复了hotshot 模块的一个关于时间计量的严重 bug。cProfile 模块是 Python2.5 新增的， 它用来替换掉已经有历史的 hotshot 和 profile 模块。被作者确认的它的一个较明显的缺点是它需要花较长时间从日志文件中载入分析结果， 不支持子函数状态细节及某些结果不准。它也是用 C 语言来实现的。

### 第4章 Python 对象



