# Python核心编程（第二版）

## 第2章 Python 基础

Python交互式解释器中存在主提示符( >>> )和次提示符( ... )。主提示符是解释器告诉你它在等待你输入下一个语句，次提示符告诉你解释器正在等待你输入当前语句的其它部分。

Python 有两种主要的方式来完成需要的要求：语句和表达式（函数、算术表达式等）。语句使用关键字来组成命令，类似告诉解释器一个命令。而表达式没有关键字。它们可以是使用数学运算符构成的算术表达式，也可以是使用括号调用的函数。它们可以接受用户输入，也可以不接受用户输入，有些会有输出，有些则没有。

交互式解释器中，用 print 来显示变量的内容和仅用变量名显示是不同的，print语句调用str()函数显示对象，而交互式解释器则调用repr()函数来显示对象。repr 函数是 对象的字符串表示，而不仅仅是字符串本身。

下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。

Print 语句也支持将输出重定向到文件。这个特性是从Python2.0 开始新增的。符号 >> 用来重定向输出。

raw_input()内建函数读取标准输入，并将读取到的数据赋值给指定的变量。

Python 也使用 # 符号标示注释，从 # 开始，直到一行结束的内容都是注释。有一种叫做文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能。

Python 不支持 C 语言中的自增 1 和自减 1 运算符， 这是因为 + 和 － 也是单目运算符，Python 会将 --n 解释为-(-n) 从而得到 n , 同样 ++n 的结果也是 n。

Python 中字符串被定义为引号之间的字符集合。Python 支持使用成对的单引号或双引号，三引号（三个连续的单引号或者双引号）可以用来包含特殊字符。使用索引运算符( [ ] )和切片运算符( [ : ] )可以得到子字符串。字符串有其特有的索引规则：第一个字符的索引是 0，最后一个字符的索引是 -1。加号( + )用于字符串连接运算，星号( * )则用于字符串重复。

Python 中的 for 循环与传统的 for 循环（计数器循环）不太一样， 它更象 shell 脚本里的 foreach 迭代。Python 中的 for 接受可迭代对象（例如序列或迭代器）作为其参数，每次迭代其中一个元素。print 语句默认会给每一行添加一个换行
符。只要在 print 语句的最后添加一个逗号(,)， 就可以改变它这种行为。

enumerate()函数可同时得到集合的索引及元素。

函数中没有 return 语句， 会自动返回 None 对象。Python 是通过引用调用的。 这意味着函数内对参数的改变会影响到原始对象。不过事实上只有可变对象会受此影响， 对不可变对象来说， 它的行为类似按值调用。

在类中，所有名字开始和结束都有两个下划线的方法都是特殊方法。而self则是类实例自身的引用。其他语言通常使用一个名为 this 的标识符。

## 第3章 Python 基础

Python 语句中有一些基本规则和特殊字符：

- 井号(#)表示之后的字符为 Python 注释
- 换行 (\n) 是标准的行分隔符（通常一个语句一行）
- 反斜线 ( \ ) 继续上一行
- 分号 ( ; )将两个语句连接在一行中
- 冒号 ( : ) 将代码块的头和体分开
- 语句（代码块）用缩进块的方式体现
- 不同的缩进深度分隔不同的代码块
- Python 文件以模块的形式组织

Python 语言中， 等号(=)是主要的赋值运算符。注意，赋值并不是直接将一个值赋给一个变量。在 Python 语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还是一个已经存在的，都是将该对象的引用（并不是值）赋值给变量。

Python 的赋值语句不会返回值。

增值赋值：x += 1

多重赋值：x = y = z = 1

“多元”赋值：x, y, z = 1, 2, 'a string'   ;   x, y = y, x

标识符是电脑语言中允许作为名字的有效字符串集合。其中，有一部分是关键字，构成语言的标识符。这样的标识符是不能做它用的标识符的，否则会引起语法错误（SyntaxError 异常）。Python 还有称为 built-in 标识符集合，虽然它们不是保留字，但是不推荐使用这些特别的名字。任何语言的关键字应该保持相对的稳定，但是因为 Python 是一门不断成长和进化的语言，关键字列表和 iskeyword()函数都放入了 keyword模块以便查阅。

除了关键字之外，Python 还有可以在任何一级代码使用的“内建”的名字集合，这些名字可以由解释器设置或使用。虽然 built-in 不是关键字，但是应该把它当作“系统保留字”，不做他用。然而，有些情况要求覆盖（也就是：重定义，替换）它们。Python 不支持重载标识符，所以任何时刻都只有一个名字绑定。built-in 是__builtins__模块的成员，在你的程序开始或在交互解释器中给出>>>提示之前，由解释器自动导入的。把它们看成适用在任何一级 Python 代码的全局变量。

Python 用下划线作为变量前缀和后缀指定特殊变量。

_xxx 不用'from module import *'导入
\__xxx__系统定义名字
__xxx 类中的私有变量名

Python 还提供了一个机制，可以通过__doc__特别变量，动态获得文档字串。在模块，类声明，或函数声明中第一个没有赋值的字符串可以用属性 obj.__doc__来进行访问，其中 obj是一个模块，类，或函数的名字。这在运行时刻也可以运行。

PEP 20 写的是 Python 之禅，你可以从那里开始你探索“Pythonic”真正含义的旅程。如果你不能上网，但想看到这篇诗句，那就从你的 Python 解释器输入 import this 然后回车。

所有的模块都有能力来执行代码。最高级别的 Python 语句－－也就是说， 那些没有缩进的代码行在模块被导入时就会执行， 不管是不是真的需要执行。由于有这样一个“特性”，比较安全的写代码的方式就是除了那些真正需要执行的代码以外， 几乎所有的功能代码都在函数当中。再说一遍， 通常只有主程序模块中有大量的顶级可执行代码，所有其它被导入的模块只应该有很少的顶级执行代码，所有的功能代码都应该封装在函数或类当中。

由于主程序代码无论模块是被导入还是被直接执行都会运行， 我们必须知道模块如何决定运行方向。一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码（否则就只能用拷贝粘贴那种非面向对象的愚蠢手段）。这种情况下，你只想访问那些位于其它应用程序中的代码，而不是想运行那个应用程序。因此一个问题出现了，“Python 是否有一种方法能在运行时检测该模块是被导入还是被直接执行呢？”  __name__ 系统变量就是正确答案。
如果模块是被导入， \__name__ 的值为模块名字
如果模块是被直接执行， \__name__ 的值为 '__main__'

Python 中变量名无需事先声明，也无需类型声明。Python 语言中，对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python 仍然是一种解释型语言。在创建---也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的应用会被赋值给左侧的变量。

Python 解释器承担了内存管理的复杂任务， 这大大简化了应用程序的编写。Python 使用了引用计数来追踪内存中的对象。

引用计数增加：当对象被创建并（将其引用）赋值给变量时，该对象的引用计数就被设置为 1。当同一个对象（的引用）又被赋值给其它变量时，或作为参数传递给函数， 方法或类实例时， 或者被赋值为一个窗口对象的成员时，该对象的一个新的引用，或者称作别名，就被创建（则该对象的引用计数自动加 1）。

引用计数减少：一个本地引用离开了其作用范围；对象的别名被显式的销毁（del）；对象的一个别名被赋值给其它的对象；；对象被从一个窗口对象中移除；窗口对象本身被销毁。

不再被使用的内存会被一种称为垃圾收集的机制释放。解释器跟踪对象的引用计数，垃圾收集器负责释放内存。垃圾收集器是一块独立代码， 它用来寻找引用计数为 0 的对象。它也负责检查那些虽然引用计数大于 0 但也应该被销毁的对象。 特定情形会导致循环引用。一个循环引用发生在当你有至少两个对象互相引用时， 也就是说所有的引用都消失时， 这
些引用仍然存在， 这说明只靠引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。 当一个对象的引用计数变为 0，解释器会暂停，释放掉这个对象和仅有这个对象可访问（可到达）的其它对象。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。

使用局部变量替换模块变量：类似 os.linesep 这样的名字需要解释器做两次查询： （1）查找 os 以确认它是一个模块，
（2）在这个模块中查找 linesep 变量。因为模块也是全局变量， 我们多消耗了系统资源。如果在一个函数中类似这样频繁使用一个属性，我们建议你为该属性取一个本地变量别名。 变量查找速度将会快很多－－在查找全局变量之前， 总是先查找本地变量。 这也是一个让你的程序跑的更快的技巧： 将经常用到的模块属性替换为一个本地引用。代码跑得更快，而也不用老是敲那么长的变量名了。

```python
#!/usr/bin/env Python

'readTextFile.py -- read and display text file'

# get filename
fname = raw_input('Enter filename: ')
print
# attempt to open file for reading
try:
	fobj = open(fname, 'r')
except IOError, e:
	print "*** file open error:", e
else:
# display contents to the screen
	for eachLine in fobj:
		print eachLine,
	fobj.close()
```

由于我们没有移除代表每行结束的行结束符，我们不得不抵制 print 语句自动生成的行结束符 －－通过在 print 语句的最后加一个逗号可以达到这一目的。

Python 代码风格指南（PEP8）, Python 快速参考和 Python 常见问答都是开发者很重要的“工具”。另外， 还有一些模块会帮助你成为一个优秀的 Python 程序员。
Debugger: pdb
Logger: logging
Profilers: profile, hotshot, cProfile

调试模块 pdb 允许你设置（条件）断点，代码逐行执行，检查堆栈。它还支持事后调试。
logging 模块是在 Python2.3 中新增的， 它定义了一些函数和类帮助你的程序实现灵活的日志系统。共有五级日志级别： 紧急， 错误，警告，信息和调试。
历史上，因为不同的人们为了满足不同的需求重复实现了很多性能测试器，Python 也有好几个性能测试模块。 最早的 Python profile 模块是 Python 写成的，用来测试函数的执行时间，及每次脚本执行的总时间，既没有特定函数的执行时间也没有被包含的子函数调用时间。在三个 profile 模块中，它是最老的也是最慢的，尽管如此， 它仍然可以提供一些有价值的性能信息。 hotshot 模块是在 Python2.2 中新增的，它的目标是取代 profile 模块， 它修复了profile 模块的一些错误， 因为它是用 C 语言写成，所以它有效的提高了性能。 注意 hotshot重点解决了性能测试过载的问题， 但却需要更多的时间来生成结果。Python2.5 版修复了hotshot 模块的一个关于时间计量的严重 bug。cProfile 模块是 Python2.5 新增的， 它用来替换掉已经有历史的 hotshot 和 profile 模块。被作者确认的它的一个较明显的缺点是它需要花较长时间从日志文件中载入分析结果， 不支持子函数状态细节及某些结果不准。它也是用 C 语言来实现的。

## 第4章 Python 对象

Python 使用对象模型来存储数据。构造任何类型的值都是一个对象。所有的 Python 对像都拥有三个特性：身份，类型和值。

- 身份：每一个对象都有一个唯一的身份标识自己，任何对象的身份可以使用内建函数 id()来得到。这个值可以被认为是该对象的内存地址。
- 类型：对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。您可以用内建函数 type()查看 Python 对象的类型。因为在 Python 中类型也是对象，所以 type()返回的是对象而不是简单的字符串。
- 值：对象表示的数据项。

上面三个特性在对象创建的时候就被赋值，除了值之外，其它两个特性都是只读的。如果对象支持更新操作，那么它的值就可以改变，否则它的值也是只读的。对象的值是否可以更改被称为对象的可改变性（mutability）。

某些 Python 对象有属性、值或相关联的可执行代码，比如方法（method）。Python 用点（.）标记法来访问属性。

标准类型：

数字（分为几个子类型，其中有三个是整型）
整型
布尔型
长整型
浮点型
复数型
字符串
列表
元组
字典

其他內建类型：

类型
Null 对象 (None)
文件
集合/固定集合
函数/方法
模块
类

```python
>>>type(type(42))
<type 'type'>
```

所有类型对象的类型都是 type，它也是所有 Python 类型的根和所有 Python 标准类的默认元类（metaclass）。

Python 有一个特殊的类型，被称作 Null 对象或者 NoneType，它只有一个值，那就是 None。它不支持任何运算也没有任何内建方法。如果非常熟悉 C 语言，和 None 类型最接近的 C 类型就是 void，None 类型的值和 C 的 NULL 值非常相似。

所有标准对象均可用于布尔测试，同类型的对象之间可以比较大小。每个对象天生具有布尔 True 或 False 值。空对象、值为零的任何数字或者 Null 对象 None 的布尔值都是 False。
下列对象的布尔值是 False：
None
False (布尔类型)
所有的值为零的数：
0 (整型)
0.0 (浮点型)
0L (长整型)
0.0+0.0j (复数)
"" (空字符串)
[] (空列表)
() (空元组)
{} (空字典)
值不是上面列出来的任何值的对象的布尔值都是 True，例如 non-empty、 non-zero 等等。用户创建的类实例如果定义了 nonzero(__nonzero__())或 length（__len__()）且值为 0，那么它们的布尔值就是 False。

代码对象是编译过的 Python 源代码片段，它是可执行对象。通过调用内建函数 compile()可以得到代码对象。代码对象可以被 exec 命令或 eval()内建函数来执行。代码对象本身不包含任何执行环境信息， 它是用户自定义函数的核心， 在被执行时动态获得上下文。（事实上代码对象是函数的一个属性）一个函数除了有代码对象属性以外，还有一些其它函数必须的属性，包括函数名，文档字符串，默认参数，及全局命名空间等等。

帧对象表示 Python 的执行栈帧。帧对象包含 Python 解释器在运行时所需要知道的所有信息。它的属性包括指向上一帧的链接，正在被执行的代码对象，本地及全局名字空间字典以及当前指令等。每次函数调用产生一个新的帧，每一个帧对象都会相应创建一个 C 栈帧。用到帧对象的一个地方是跟踪记录对象。

当你的代码出错时， Python 就会引发一个异常。当异常发生时，一个包含针对异常的栈跟踪信息的跟踪记录对象被创建。如果一个异常有自己的处理程序，处理程序就可以访问这个跟踪记录对象。

当使用 Python 扩展的切片语法时，就会创建切片对象。扩展的切片语法允许对不同的索引切片操作，包括步进切片， 多维切片，及省略切片。多维切片语法是 sequence[start1 : end1,start2 : end2]， 或使用省略号， sequence[...,start1 : end1 ]. 切片对象也可以由内建函数 slice()来生成。步进切片允许利用第三个切片元素进行步进切片，它的语法为sequence[起始索引 : 结束索引 : 步进值]。

省略对象用于扩展切片语法中，起记号作用。 这个对象在切片语法中表示省略号。类似Null 对象 None, 省略对象有一个唯一的名字 Ellipsis,，它的布尔值始终为 True。

调用内建函数 xrange() 会生成一个 Xrange 对象，xrange()是内建函数 range()的兄弟版本， 用于需要节省内存使用或 range()无法完成的超大数据集场合。

比较运算符用来判断同类型对象是否相等，所有的内建类型均支持比较运算，比较运算返回布尔值 True 或 False。实际进行的比较运算因类型而异。比如，数字类型根据数值的大小和符号比较，字符串按照字符序列值进行比较，等等。

不同于很多其它语言，多个比较操作可以在同一行上进行，求值顺序为从左到右。

```python
>>> 3 < 4 < 7 # same as ( 3 < 4 ) and ( 4 < 7 )
True
>>> 4 > 3 == 3 # same as ( 4 > 3 ) and ( 3 == 3 )
True
>>> 4 < 3 < 5 != 2 < 7
False
```

作为对值比较的补充，Python 也支持对象本身的比较。对象可以被赋值到另一个变量（通过引用）。因为每个变量都指向同一个（共享的）数据对象，只要任何一个引用发生改变，该对象的其它引用也会随之改变。

```python
>>>foo1 = 4.3
>>>foo2 = 1.3 + 3.0
>>>foo1 is foo2 # id(foo1) == id(foo2),is 比较对象,is / is not
False
```

将foo1、foo2改为整数得到不一样的结果。因为整数对象和字符串对象是不可变对象，所以 Python 会很高效的缓存它们。这会造成我们认为 Python 应该创建新对象时，它却没有创建新对象的假象。

Python 仅缓存简单整数，因为它认为在 Python 应用程序中这些小整数会经常被用到。（可写一段代码，作比较得出当前版本的缓存范围）

```python
a = 0
b = 0
while True:
    if a is not b:
        print('value : %d' % a)
        break
    a += 1
    b += 1
```

Python 提供了一些内建函数用于这些基本对象类型：cmp(), repr(), str(), type(), 和等同于 repr()函数的单反引号(``) 运算符。str()函数得到的字符串可读性好， 而 repr()函数得到的字符串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的，并不是所有 repr()返回的字符串都能够用
eval()内建函数得到原来的对象。这两个函数接受一个对象做为其参数， 返回适当的字符串。

除了内建函数 type()， 还有一个有用的内建函数叫 isinstance()。下列几种方法来确认 数值类型：

```python
if isinstance(num, (int, long, float, complex)):
	print 'a number of type:', type(num).__name__
else:
	print 'not a number at all!!'
```

```python
if type(num) == type(0):
	print 'an integer'
elif type(num) == type(0L):
	print 'a long'
elif type(num) == type(0.0):
	print 'a float'
elif type(num) == type(0+0j):
	print 'a complex number'
else:
	print 'not a number at all!!'
```

调用两次type()，要知道每次调用函数都会付出性能代价， 如果我们能减少函数的调用次数， 就会提高程序的性能。利用types模块：

```python
>>> import types
>>> if type(num) == types.IntType...
```

在运行时期,只有一个类型对象来表示整数类型。也就是说,type(0),type(42),type(-100) 都是同一个对象: <type 'int'>(types.IntType 也
是这个对象)。如果它们是同一个对象, 我们为什么还要浪费时间去获得并比较它们的值呢(我们已经知道它们是相同的了!)? 所以比较对象本身是一个更好地方案.下面是改进后的代码：

```python
if type(num) is types.IntType... # or type(0)
```

我们用对象身份的比较来替代对象值的比较。如果对象是不同的，那意
味着原来的变量一定是不同类型的。(因为每一个类型只有一个类型对象)，我们就没有必要去检查(值)了。 一次这样的调用可能无关紧要，不过当很多类似的代码遍布在你的应用程序中的时候，就有影响了。

为了得到整数的对象类型，解释器不得不首先查找 types 这个模块
的名字，然后在该模块的字典中查找 IntType。通过使用 from-import，你可以减少一次查询：

```python
from types import IntType
if type(num) is IntType...
```

isinstance()接受一个或多个对象做为其参数，由于类型和类现在都是一回事， int 现在既是一个类型又是一个类。我们可以使用 isinstance() 函数来让我们的 if 语句更方便，并具有更好的可读性。
if isinstance(num, int)...
在判断对象类型时也使用 isinstance() 已经被广为接受。值得一提的是， isinstance()接受一个类型对象的元组做为参数， 这样我们就不必像使用 type()时那样写一堆 if-elif-else 判断了。

在 operator 模块中有和绝大多数 Python运算符相应的同功能的函数可供使用。

Python 2.2 统一了类型和类， 所有的内建类型现在也都是类， 在这基础之上， 原来的所谓内建转换函数象 int(), type(), list() 等等， 现在都成了工厂函数。 也就是说虽然它们看上去有点象函数， 实质上他们是类。当你调用它们时， 实际上是生成了该类型的一个实例， 就象工厂生产货物一样。下面这些大家熟悉的工厂函数在老的 Python 版里被称为内建函数：

- int(), long(), float(), complex()
- str(), unicode(), basestring()
- list(), tuple()
- type()

以前没有工厂函数的其他类型，现在也都有了工厂函数。除此之外，那些支持新风格的类的全新的数据类型，也添加了相应的工厂函数。下面列出了这些工厂函数：

- dict()
- bool()
- set(), frozenset()
- object()
- classmethod()
- staticmethod()
- super()
- property()
- file()

标准类型分类

一个能保存单个字面对象的类型我们称它为原子或标量存储，那些可容纳多个对象的类型，我们称之为容器存储。所有的 Python 容器对象都能够容纳不同类型的对象。

| 分类      | Python类型              |
| ------- | --------------------- |
| 标量/原子类型 | 数值（所有数值类型），字符串（全部是文字） |
| 容器类型    | 列表、元组、字典              |

根据创建之后是否可改(id())，分为：

| 分类    | Python类型                  |
| ----- | ------------------------- |
| 可变类型  | 列表，字典                     |
| 不可变类型 | 数字、字符串、元组 （重新赋值，新对象取代旧对象） |

根据访问存储的数据的方式对数据类型进行分类。

| 分类         | Python类型  |
| ---------- | --------- |
| 直接访问       | 数字        |
| 顺序访问（存在索引） | 字符串、列表、元组 |
| 映射访问       | 字典        |

| 数据类型 | 存储模型      | 更新模型 | 访问模型 |
| ---- | --------- | ---- | ---- |
| 数字   | Scalar    | 不可更改 | 直接访问 |
| 字符串  | Scalar    | 不可更改 | 顺序访问 |
| 列表   | Container | 可更改  | 顺序访问 |
| 元组   | Container | 不可更改 | 顺序访问 |
| 字典   | Container | 可更改  | 映射访问 |

## 第5章 数字



## 第6章 序列：字符串、列表和元组

## 第7章 映像和集合类型

## 第8章 条件和循环

## 第9章 文件和输入输出

## 第10章 错误和异常




