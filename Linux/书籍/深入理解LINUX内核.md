## 第1章 绪论

Linux是类Unix (Unix-like)操作系统大家族中的一名成员。1991年，Linus Torvalds开发出最初的Linux，它作为一个适用于基于Intel 80386微处理器的IBM PC兼容机的操作系统。Linux最吸引人的一个优点就在于它不是商业操作系统：它的源代码在GNU公共许可证(General Pwblic License, GPL)下是开放的，任何人都可以获得源代码并研究它。

从技术角度来说，Linux是一个真正的Unix内核，但它不是一个完全的Unix操作系统，这是因为它不包含全部的Unix应用程序，诸如文件系统实用程序、窗口系统及图形化桌面、系统管理员命令、文本编辑程序、编译程序等等。不过，因为以上大部分应用程序都可在GNU许可证下免费获得，因此，可以把它们安装在任何一个基于Linux内核的系统中。

### Linux 和 其他类Unix内核的比较

Linux与一些著名的商用Unix内核到底如何竞争，下面给予描述：

- 单块结构的内核(Monolithic kernel)

  它是一个庞大、复杂的自我完善(do-it-yourself)程序，由几个逻辑上独立的成分构成。在这一点上，它是相当传统的，大多数商用Unix变体也是单块结构。(一个显著的例外是Apple的Mac Os X和GNU的Hurd操作系统，它们都是从卡耐基-梅隆大学的Mach演变而来的，都遵循微内核的方法。)


- 编泽并静态连接的传统Unix内核

  大部分现代操作系统内核可以动态地装载和卸载部分内核代码(典型的例子如设备驱动程序)，通常把这部分代码称做模块(module)。Linux对模块的支持是很好的，因为它能自动按需装载或卸载模块。在主要的商用Unix变体中，只有SVR4.2和Solaris内核有类似的特点。


- 内核线程

  一些Unix内核，如Solaris和SVR4.2/MP，被组织成一组内核线程( kernel thread )。内核线程是一个能被独立调度的执行环境(context)，也许它与用户程序有关，也许仅仅执行一些内核函数。线程之间的上下文切换比普通进程之间的上下文切换花费的代价要少得多，因为前者通常在同一个地址空间执行。Linux以一种十分有限的方式使用内核线程来周期性地执行几个内核函数，但是，它们并不代表基本的执行上下文的抽象(这就是下面要讨论的议题)。


- 多线程应用程序支持

  大多数现代操作系统在某种程度上都支持多线程应用程序，也就是说，这些用户程序是根据很多相对独立的执行流来设计的，而这些执行流之间共享应用程序的大部分数据结构。一个多线程用户程序由很多轻量级进程(lightweight process, LWP)组成，这些进程可能对共同的地址空间、共同的物理内存页、共同的打开文件等等进行操作。Linux定义了自己的轻量级进程版本，这与SVR4, Solaris等其他系统上所使用的类型有所不同。当LWP的所有商用Unix变体都基于内核线程时，Linux却把轻量级进程当作基本的执行上下文，通过非标准的clone()系统调用来处理它们。


- 抢占式(preemptive) 

  当采用“可抢占的内核”选项来编译内核时，Linux2.6可以随意交错执行处于特权模式的执行流。除了Linux 2.6，还有其他一些传统的、通用的Unix系统(如Solaris和Mach3.0)是完全的抢占式内核。S V R4.2/M P通过引入一些固定抢占点(fixed preemption goint)的方法获得有限的抢占能力。


- 多处理器支持

  几种Unix内核变体都利用了多处理器系统。Linux 2.6支持不同存储模式的对称多处理(SMP)，包括NUMA:系统不仅可以使用多处理器，而且每个处理器可以毫无区别地处理任何一个任务。尽管通过一个单独的“大内核锁”使得内核中的少数代码依然串行执行，但公平地说，Linux 2.6以几乎最优化的方式使用SMP。


- 文件系统

  Linux标准文件系统呈现出多种风格。如果你没有特殊需要，就可以使用普通的Ext2文件系统。如果你想避免系统崩溃后冗长的文件系统检查，就可以切换到Ext3。如果你不得不处理很多小文件，ReiserFS文件系统可能就是最好的选择。除了Ext3和ReiserFS，还可以在Linux中使用另外几个日志文件系统，这些文件系统包括IBM AIX的日志文件系统(Journaling File System, JFS)和SGI公司IRIX 系统上的XFS文件系统。有了强大的面向对象虚拟文件系统技术(为Solaris和SVR4所采用)，把外部文件系统移植到Linux比移植到其他内核相对要容易。


- STREAMS

  尽管现在大部分的Unix内核内包含了SRV4引入的STREAMS I/O子系统，并且 已变成编写设备驱动程序、终端驱动程序及网络协议的首选接口，但是Linux并没有与此类似的子系统。

与商业化的操作系统相比，Linux已经具备足够的竞争力。而且，Linux一些独具特色的特点使其成为一种趣味盎然的操作系统。商业化的Unix内核为了赢得更大的市场份额通常也引入了新特征，但这些特征本是可有可无，其稳定性和效率都值得商榷。事实上，现代Unix内核有向更臃肿变化的倾向，而Linux以及其他开放源代码的操作系统不受市场因素的制约，因此可以根据设计者的想法(主要是Linus Torvalds的想法)自由地演进。尤其是，与商用竞争对手相比，Linux有如下优势:

- Linux是免费的。除硬件之外，你无需任何花费就能安装一套完整的Linux系统。

- Linux的所有成分都可以充分地定制。通过内核编译选项，你可以选择自己真正需要的特征来定制内核。
- Linux可以运行在低档、便宜的硬件平台上。你可以用一个4MB内存的旧Intel 80386系统构建网络服务器。
- Linux是强大的。由于充分挖掘了硬件部分的特点，使得Linux系统速度非常快。Linux的主要目标是效率，所以，商用系统的许多设计选择由于有降低性能的隐患而被Linus舍弃，如STREAMSI/O子系统。
- Linux的开发者都是非常出色的程序员。Linux系统非常稳定，有非常低的故障率和非常少系统维护时间。
- Linux内核非常小，而且紧凑。我们甚至可以把一个内核映像和一些系统程序放在一张1.4MB的软盘上!据我们所知，没有一个商用Unix变体能从一张软盘上启动。
- Linux与很多通用操作系统商度兼容。Linux可以让你直接安装以下文件系统的所有版本:MS-DOS和MS Windows, SVR4, OS/2,  Mac OS X, Solaris, SunOS, NEXTSTEP，还有很多BSD变体等等。另外， Linux也能对很多网络层进行操作，这些网络层如以太网[如:快速以太网和高速(Gbit/s及lOGbit/s)以太网]、光纤分布式数据接口(Fiber Distributed Data Interface, FDDI)、高性能并行接口( High Performance Parallel Interface,  HIPPI ) ,  IEEE 802.11(无线局域网)和IEEE802.15(蓝牙)。。通过使用适当的库函数，Linux系统甚至能直接运行为其他操作系统所编写的程序。例如，Linux能执行为以下操作系统所编写的应用程序: MS-DOS,  MS Windows, SVR3及SV R4, 4.4BSD,  SCO Unix, Xenix，以及其他在Intel 80x86平台上运行的操作系统。
- Linux有很好的技术支持。

### 硬件的依赖性

Linux试图在硬件无关的源代码与硬件相关的源代码之间保持清晰的界限。为了做到这点，在arch和include目录下包含了23个子目录，以对应Linux所支持的不同硬件平台。这些平台的标准名字如下：

| 平台            | 简介                                       |
| ------------- | ---------------------------------------- |
| alpha         | HP的Alpha工作站，最早属于Digital公司，后来属于Cpmpag公司，现在不再生产。 |
| arm,arm26     | 基于ARM处理器的计算机（如PDA）和嵌入式设备。                |
| cris          | Axis在它的瘦服务器中使用的“代码精简指令集（Code Reduced Instruction Set）”CPU，用在诸如Web摄像机或开发主板中。 |
| frv           | 基于Fujitsu FR-V系列微处理器的嵌入式系统。              |
| h8300         | Hitachi h8/300 和 h8S的8位和16位RISC微处理器。     |
| i386          | 基于80x86微处理器的IBM兼容个人计算机。                  |
| ia64          | 基于64位Itanium微处理器的工作站。                    |
| m32r          | 基于Renesas M32R系列微处理器的计算机。                |
| m68k,m68nommu | 基于Motorola MC680x0微处理器的个人计算机。            |
| mips          | 基于MIPS微处理器的工作站。                          |
| parisc        | 基于HP公司HP 9000 PA-RISC微处理器的工作站。           |
| ppc,ppc64     | 基于Motorola-IBM PowerPC32位和64位微处理器的工作站。   |
| s390          | IBM ESA/390及zSeries大型机。                  |
| sh,sh64       | 基于Hitachi和STMicroelectronics联合开发的SuperH微处理器的嵌入式系统。 |
| sparc,sparc64 | 基于Sun公司SPARC和64位Ultra SPARC微处理器的工作站。     |
| um            | 用户态的Linux——一个允许开发者在用户态下运行内核的虚拟平台。        |
| v850          | 集成了基于Harvard体系结构的32位RISC核心的NEC V850微控制器。 |
| x86_64        | 基于AMD的64位微处理器的工作站。                       |

### Linux版本

一直到2.5版本的内核，Linux都通过简单的编号来区别内核的稳定版和开发版。每个版本号用三个数字描述，由圆点分隔。前两个数字用来表示版本号，第三个数字表示发布号。第二位版本号表示内核的类型:如果为偶数，表示稳定的内核；否则，表示开发中的内核。

在Linux内核2.6版的开发过程中，内核版本的编号方式发生了很大的变化。主
要变化在于第二个数字已经不再用于表示一个内核是稳定版本还是正在开发的版本。因此，现在内核开发者都在当前的2.6版本中对内核进行大幅改进。只有在内核开发者必须对内核的重大修改进行测试时，才会采用一个新的内核分支。这种分支要么产生一个新的内核版本，要么干脆丢弃所修改的部分而回退到2.6版。

Linux这种新的开发模式意味着两种内核具有相同的版本号，但却有不同的发布号，如2.6.10和2.6.11内核就可能在核心部件和基本算法上有很大的差别。这样一来，具有新发布号的内核可能潜藏着不稳定性和各种错误。为了解决这个问题，内核开发者可能发布带有补丁程序的内核版本，并且用第四位数字表示带有不同补丁的内核版本。例如，2.6.11.12。

必须强调的是本书描述的是Linux2.6.11版的内核。

### 操作系统基本概念

任何计算机系统都包含一个名为操作系统的基本程序集合。在这个集合里，最重要的程序称为内核(kernel)。当操作系统启动时，内核被装入到RAM中，内核中包含了系统运行所必不可少的很多核心过程(procedure)。其他程序是一些不太重要的实用程序，尽管这些程序为用户提供了与计算机进行广泛交流的经验(以及用户买计算机要做的所有工作)，但系统根本的样子和能力还是由内核决定。内核也为系统中所有事情提供了主要功能，并决定高层软件的很多特性。因此，我们将经常使用术语“操作系统”作为“内核”的同义词。操作系统必须完成两个主要目标：

- 与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务。
- 为运行在计算机系统上的应用程序(即所谓用户程序)提供执行环境。

一些操作系统允许所有的用户程序都直接与硬件部分进行交互(典型的例子是MS-DOS)。与此相反，类Unix操作系统把与计算机物理组织相关的所有低层细节都对用户运行的程序隐藏起来。当程序想使用硬件资源时，必须向操作系统发出一个请求。内核对这个请求进行评估，如果允许使用这个资源，那么，内核代表应用程序与相关的硬件部分进行交互。

为了实施这种机制，现代操作系统依靠特殊的硬件特性来禁止用户程序直接与低层硬件部分进行交互，或者禁止直接访问任意的物理地址。特别是，硬件为CPU引入了至少两种不同的执行模式：用户程序的非特权模式和内核的特权模式。Unix把它们分别称为用户态(User Mode)和内核态(Kernel Mode )。

#### 多用户系统

多用户系统(multiuser system)就是一台能并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机。

- “并发”(concurrently)意味着几个应用程序能同时处于活动状态并竟争各种资源，如CPU、内存、硬盘等等。
- “独立”( independently)意味着每个应用程序能执行自己的任务，而无需考虑其他用户的应用程序在干些什么。

当然，从应用程序切换会使每个应用程序的速度有所减慢，从而影响用户看到的响应时间。现代操作系统内核提供的许多复杂特性减少了强加在每个程序上的延迟时间，给用户提供了尽可能快的响应时间。

多用户操作系统必须包含以下几个特点：

- 核实用户身份的认证机制。
- 防止有错误的用户程序防碍其他应用程序在系统中运行的保护机制。
- 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制。
- 限制分配给每个用户的资源数的计账机制。

为了确保能实现这些安全保护机制，操作系统必须利用与CPU特权模式相关的硬件保护机制，否则，用户程序将能直接访问系统电路并克服强加于它的这些限制。unix是实施系统资源硬件保护的多用户系统。

#### 用户和组

在多用户系统中，每个用户在机器上都有私用空间；典型地，他拥有一定数量的磁盘空间来存储文件、接收私人邮件信息等等。操作系统必须保证用户空间的私有部分仅仅对其拥有者是可见的。特别是必须能保证，没有用户能够开发一个用于侵犯其他用户私有空间的系统应用程序。

所有的用户由一个惟一的数字来标识，这个数字叫用户标识符(User ID,  UID)。通常一个计算机系统只能由有限的人使用。当其中的某个用户开始一个工作会话时，操作系统要求输入一个登录名和口令，如果用户输入的信息无效，则系统拒绝访问。因为口令是不公开的，所以用户的保密性得到了保证。

为了和其他用户有选择地共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的用户组标识符(user group ID)标识。每个文件也恰好与一个组相对应。例如，可以设置这样的访问权限，拥有文件的用户具有对文件的读写权限，同组用户仅有只读权限，而系统中的其他用户没有对文件的任何访问权限。

任何类Unix操作系统都有一个特殊的用户，叫做root，即超级用户(superuser)。系统管理员必须以root的身份登录，以便处理用户账号，完成诸如系统备份、程序升级等维护任务。root用户几乎无所不能，因为操作系统对他不使用通常的保护机制。尤其是，root用户能访向系统中的每一个文件，能干涉每一个正在执行的用户程序的活动。

#### 进程

所有的操作系统都使用一种基本的抽象:进程(process)。一个进程可以定义为:“程序执行时的一个实例”，或者一个运行程序的“执行上下文”。在传统的操作系统中，一个进程在地址空间(address space)中执行一个单独的指令序列。地址空间是允许进程引用的内存地址集合。现代操作系统允许具有多个执行流的进程，也就是说，在相同的地址空间可执行多个指令序列。

多用户系统必须实施一种执行环境，在这种环境里，几个进程能并发活动，并能竟争系统资源(主要是CPU )。允许进程并发活动的系统称为多道程序系统(multiprogramming)或多处理系统(multiprocessing)。区分程序和进程是非常重要的：几个进程能并发地执行同一程序，而同一个进程能顺序地执行几个程序。

在单处理器系统上，只有一个进程能占用CPU，因此，在某一时刻只能有一个执行流。一般来说，CPU的个数总是有限的，因而只有少数几个进程能同时执行。操作系统中叫做调度程序(scheduler)的部分决定哪个进程能执行。一些操作系统只允许有非抢占式(nonpreemptable)进程，这就意味着，只有当进程自愿放弃CPU时，调度程序才被调用。但是，多用户系统中的进程必须是抢占式的(preemptable )。操作系统记录下每个进程占有的CPU时间，并周期性地激活调度程序。

Unix是具有抢占式进程的多处理操作系统。即使没有用户登录，没有程序运行，也还是有几个系统进程在监视外围设备。尤其是，有几个进程在监听系统终端等待用户登录。当用户输人一个登录名，监听进程就运行一个程序来验证用户的口令。如果用户身份得到证实，那么监听进程就创建另一个进程来执行shell，此时在shell下可以输人命令。当一个图形化界面被激活时，有一个进程就运行窗口管理器，界面上的每个窗口通常都由一个单独的进程来执行。如果用户创建了一个图形化shell，那么，一个进程运行图形化窗口，而第二个进程运行用户可以输人命令的shell。对每一个用户命令，shell进程都创建执行相应程序的另一个进程。

Unix操作系统采用进程/内核模式。每个进程都自以为它是系统中唯一的进程，可以独占操作系统所提供的服务。只要进程发出系统调用(即对内核提出请求)，硬件就会把特权模式由用户态变成内核态，然后进程以非常有限的目的开始一个内核过程的执行。这样，操作系统在进程的执行上下文中起作用，以满足进程的请求。一旦这个请求完全得到满足，内核过程将迫使硬件返回到用户态，然后进程从系统调用的下一条指令继续执行。

#### 内核体系结构

如前所述，大部分Unix内核是单块结构:每一个内核层都被集成到整个内核程序中，并代表当前进程在内核态下运行。相反，微内核(microkernel)操作系统只需要内核有一个很小的函数集，通常包括几个同步原语、一个简单的调度程序和进程间通信机制。运行在微内核之上的几个系统进程实现从前操作系统级实现的功能，如内存分配程序、设备驱动程序、系统调用处理程序等等。

尽管关于操作系统的学术研究都是面向微内核的，但这样的操作系统一般比单块内核的效率低，因为操作系统不同层次之间显式的消息传递要花费一定的代价。不过，微内核操作系统比单块内核有一定的理论优势。微内核操作系统迫使系统程序员采用模块化的方法，因为任何操作系统层都是一个相对独立的程序，这种程序必须通过定义明确而清晰的软件接口与其他层交互。此外，已有的微内核操作系统可以很容易地移植到其他的体系结构上，因为所有与硬件相关的部分都被封装进微内核代码中。最后，微内核操作系统比单块内核更加充分地利用了RAM，因为暂且不需要执行的系统进程可以被调出或撤消。

为了达到微内核理论上的很多优点而又不影响性能，Linux内核提供了模块(module) 。模块是一个目标文件，其代码可以在运行时链接到内核或从内核解除链接。这种目标代码通常由一组函数组成，用来实现文件系统、驱动程序或其他内核上层功能。与微内核操作系统的外层不同，模块不是作为一个特殊的进程执行的。相反，与任何其他静态链接的内核函数一样，它代表当前进程在内核态下执行。

使用模块的主要优点包括：

- 摸块化方法

  任何模块都可以在运行时被链接或解除链接，因此，系统程序员必须提出良定义的软件接口以访问由模块处理的数据结构。这使得开发新模块变得容易。

- 平台无关性

  即使模块依赖于某些特殊的硬件特点，但它不依赖于某个固定的硬件平台。例如，符合SCSI标淮的磁盘驱动程序模块，在IBM兼容PC与HP的Alpha机上都能很好地工作。

- 节省内存使用

  当需要模块功能时，把它链接到正在运行的内核中，否则，将该模块解除链接。这种机制对于小型嵌入式系统是非常有用的。

- 无性能损关

  模块的目标代码一旦被链接到内核，其作用与静态链接的内核的目标代码完全等价。因此，当模块的函数被调用时，无需显式地进行消息传递。

### Unix文件系统概述

Unix操作系统的设计集中反映在其文件系统上。

#### 文件

Unix文件是以字节序列组成的信息载体(container)，内核不解释文件的内容。很多编程的库函数实现了更高级的抽象，例如，由字段构成的记录以及基于关键字编址的记录。然而，这些库中的程序必须依靠内核提供的系统调用。从用户的观点来看，文件被组织在一个树结构的命名空间中。

除了叶节点之外，树的所有节点都表示目录名。目录节点包含它下面文件及目录的所有信息。文件或目录名由除“/”和空字符“\0”之外的任意ASCII字符序列组成。大多数文件系统对文件名的长度都有限制，通常不能超过255个字符。与树的根相对应的目录被称为根目录(root directory)。按照惯例，它的名字是“/”。在同一目录中的文件名不能相同，而在不同目录中的文件名可以相同。

Unix的每个进程都有一个当前工作目录，它属于进程执行上下文(execution context)，标识出进程所用的当前目录。为了标识一个特定的文件，进程使用路径名(pcothname )，路径名由斜杠及一列指向文件的目录名交替组成。如果路径名的第一个字符是斜杠，那么这个路径就是所谓的绝对路径，因为它的起点是根目录。否则，如果第一项是目录名或文件名，那么这个路径就是所谓的相对路径，因为它的起点是进程的当前目录。

当标识文件名时，也用符号“.”和“..”。它们分别标识当前工作目录和父目录。如果当前工作目录是根目录，“.”和“..”就是一致的。

#### 硬链接和软链接

包含在目录中的文件名就是一个文件的硬链接(hard link)，或简称链接(Link)。在同一目录或不同的目录中，同一文件可以有几个链接，因此对应几个文件名。

```shell
ln P1 P2
```

用来创建一个新的硬链接，即为由路径P1标识的文件创建一个路径名为P2的硬链接。
硬链接有两方面的限制：

- 不允许用户给目录创建硬链接。因为这可能把目录树变为环形图，从而就不可能通过名字定位一个文件。
- 只有在同一文件系统中的文件之间才能创建链接。这带来比较大的限制，因为现代Unix系统可能包含了多种文件系统，这些文件系统位于不同的磁盘和/或分区，用户也许无法知道它们之间的物理划分。

为了克服这些限制，引入了软链接(soft link)[也称符号链接(symbolic link)]。符号链接是短文件，这些文件包含有另一个文件的任意一个路径名。路径名可以指向位于任意一个文件系统的任意文件或目录，甚至可以指向一个不存在的文件。

```shell
ln -s  P1  P2
```

创建一个路径名为P2的新软链接，P2指向路径名P1。当这个命令执行时，文件系统抽出P2的目录部分，并在那个目录下创建一个名为P2的符号链接类型的新项。这个新文件包含路径名P1。这样，任何对P2的引用都可以被自动转换成指向P1的一个引用。

#### 文件类型

- 普通文件(regular file)
- 目录
- 符号链接
- 面向块的设备文件(block-oriented device file)
- 面向字符的设备文件(character-oriented device file)
- 管道(pipe)和命名管道(named pipe )(也叫F1F0 )
- 套接字(socket)

前三种文件类型是所有Unix文件系统的基本类型。

设备文件与I/O设备以及集成到内核中的设备驱动程序相关。例如，当程序访问设备文件时，它直接访问与那个文件相关的I/O设备。

管道和套接字是用于进程间通信的特殊文件。

#### 文件描述符与索引点

Unix对文件的内容和描述文件的信息给出了清楚的区分。除了设备文件和特殊文件系统文件外，每个文件都由字符序列组成。文件内容不包含任何控制信息，如文件长度或文件结束(end-of-file,EOF )符。
文件系统处理文件需要的所有信息包含在一个名为索引节点(inode)的数据结构中。每个文件都有自己的索引节点，文件系统用索引节点来标识文件。

虽然文件系统及内核函数对索引节点的处理可能随Unix系统的不同有很大的差异，但它们必须至少提供在POSIX标准中指定的如下属性：

- 文件类型
- 与文件相关的硬链接个数
- 以字节为单位的文件长度
- 设备标识符(即包含文件的设备的标识符)
- 在文件系统中标识文件的索引节点号
- 文件拥有者的UID
- 文件的用户组ID
- 几个时间戳，表示索引节点状态改变的时间、最后访问时间及最后修改时间
- 访问权限和文件模式

#### 访问权限和文件模式

文件的潜在用户分为三种类型：

- 作为文件所有者的用户
- 同组用户，不包括所有者
- 所有剩下的用户(其他)

有三种类型的访问权限——读、写及执行，每组用户都有这三种权限。因此，文件访问权限的组合就用9种不同的二进制来标记。还有三种附加的标记，即:uid (Set User ID),sgid (Set Group ID)，及sticky用来定义文件的模式。当这些标记应用到可执行文件时有如下含义：

- suid

  进程执行一个文件时通常保持进程拥有者的UID。然而，如果设置了可执行文件suid的标志位，进程就获得了该文件拥有者的UID。

- sgid

  进程执行一个文件时保持进程组的用户组ID。然而，如果设置了可执行文件sgid的标志位，进程就获得了该文件用户组的ID。

- sticky

  设置了sticky标志位的可执行文件相当于向内核发出一个请求，当程序执行结   束以后，依然将它保留在内存(已过时)。

当文件由一个进程创建时，文件拥有者的ID就是该进程的UID。而其用户组ID可以是进程创建者的ID，也可以是父目录的ID，这取决于父目录sgid标志位的值。

#### 文件操作的系统调用

当用户访问一个普通文件或目录文件的内容时，他实际上是访问存储在硬件块设备上的一些数据。从这个意义上说，文件系统是硬盘分区物理组织的用户级视图。因为处于用户态的进程不能直接与低层硬件交互，所以每个实际的文件操作必须在内核态下进行。因此，Unix操作系统定义了几个与文件操作有关的系统调用。

所有Unix内核都对硬件块设备的处理效率给予极大关注，其目的是为了获得非常好的系统整体性能。在后面的章节中，我们将描述Linux与文件操作相关的主题，尤其是讨论内核如何对文件相关的系统调用作出反应。为了理解这些内容，你需要知道如何使用文件操作的主要系统调用。下面对此给予描述。

##### 打开文件

进程只能访问“打开的”文件。为了打开一个文件，进程调用系统调用：

```c
fd = open(path, flag, mode);
```

- path：表示被打开文件的(相对或绝对)路径。
- flag：指定文件打开的方式(例如，读、写、读/写、追加)。它也指定是否应当创建一个不存在的文件。
- mode：指定新创建文件的访问权限。

这个系统调用创建一个“打开文件”对象，并返回所谓文件描述符(file descriptor)的标识符。一个打开文件对象包括：

- 文件操作的一些数据结构，如指定文件打开方式的一组标志;表示文件当前位置的offset字段，从这个位置开始将进行下一个操作(即所谓的文件指针)，等等。
- 进程可以调用的一些内核函数指针。这组允许调用的函数集合由参数flag的值决定。

POSIX语义所指定的一般特性：

-  文件描述符表示进程与打开文件之间的交互，而打开文件对象包含了与这种交互相关的数据。同一打开文件对象也许由同一个进程中的几个文件描述符标识。
-  几个进程也许同时打开同一文件。在这种情况下，文件系统给每个文件分配一个单独的打开文件对象以及单独的文件描述符。当这种情况发生时，Unix文件系统对进程在同一文件上发出的I/O操作之间不提供任何形式的同步机制。然而，有几个系统调用，如flock()，可用来让进程在整个文件或部分文件上对I/O操作实施同步。

为了创建一个新的文件，进程也可以调用create()系统调用，它与open()非常相似，都是由内核来处理。

##### 访问打开的文件

对普通Unix文件，可以顺序地访问，也可以随机地访问，而对设备文件和命名管道文件，通常只能顺序地访问。在这两种访问方式中，内核把文件指针存放在打开文件对象中，也就是说，当前位置就是下一次进行读或写操作的位置。

顺序访问是文件的默认访问方式，即read()和write()系统调用总是从文件指针的当前位置开始读或写。为了修改文件指针的值，必须在程序中显式地调用lseek ()系统调用。当打开文件时，内核让文件指针指向文件的第一个字节(偏移量为0)。

```c
newoffset=lseek(fd, offset，whence);
```

- fd：表示打开文件的文件描述符。
- offset：指定一个有符号整数值，用来计算文件指针的新位置。
- whence：指定文件指针新位置的计算方式。可以是offset加0，表示文件指针从文件头移动，也可以是offset加文件指针的当前位置，表示文件指针从当前位置移动;还可以是offset加文件最后一个字节的位置，表示文件指针从文件末尾开始移动。

```c
nread= read(fd, buf，count);
```

- fd：表示打开文件的文件描述符。
- buf：指定在进程地址空间中缓冲区的地址，所读的数据就放在这个缓冲区。
- count：表示所读的字节数。

当处理这样的系统调用时，内核会尝试从拥有文件描述符fd的文件中读count个字节，其起始位置为打开文件的offset字段的当前值。在某些情况下可能遇到文件结束、空管道等等，因此内核无法成功地读出全部count个字节。返回的nead值就是实际所读的字节数。给原来的值加上nread就会更新文件指针。write()的参数与read()相似。

##### 关闭文件

当进程无需再访问文件的内容时，就调用系统调用：

```c
res=close(fd);
```

释放与文件描述符fd相对应的打开文件对象。当一个进程终止时，内核会关闭其所有仍然打开着的文件。

##### 更名及删除文件

要重新命名或删除一个文件时，进程不需要打开它。实际上，这样的操作并没有对这个文件的内容起作用，而是对一个或多个目录的内容起作用。

```c
/*改变了文件链接的名字*/
res= rename(oldpath, newpath);
```

```c
/*减少了文件链接数，删除了相应的目录项。只有当链接数为0时，文件才被真正删除。*/
res= unlink(pathname);
```

### Unix 内核概述

Unix内核提供了应用程序可以运行的执行环境。因此，内核必须实现一组服务及相应的接口。应用程序使用这些接口，而且通常不会与硬件资源直接交互。

#### 进程/内核模式

CPU既可以运行在用户态下，也可以运行在内核态下。实际上，一些CPU可以有两种以上的执行状态。例如，Intel 80x86微处理器有四种不同的执行状态。但是，所有标准的Unix内核都仅仅利用了内核态和用户态。

当一个程序在用户态下执行时，它不能直接访问内核数据结构或内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。每种CPU模型都为从用户态到内核态的转换提供了特殊的指令，反之亦然。一个程序执行时，大部分时间都处在用户态下，只有需要内核所提供的服务时才切换到内核态。当内核满足了用户程序的请求后，它让程序又回到用户态下。

进程是动态的实体，在系统内通常只有有限的生存期。创建、撤消及同步现有进程的任务都委托给内核中的一组例程来完成。

内核本身并不是一个进程，而是进程的管理者。进程/内核模式假定：请求内核服务的进程使用所谓系统调用(system call)的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户态到内核态的转换。

除用户进程之外，Unix系统还包括几个所谓内核线程(kernel thread)的特权进程(被赋予特殊权限的进程)，它们具有以下特点：

- 以内核态运行在内核地址空间。
- 不与用户直接交互，因此不需要终端设备。
- 通常在系统启动时创建，然后一直处于活跃状态直到系统关闭。

在单处理器系统中，任何时候只有一个进程在运行，或处于用户态，或处于内核态。如果进程运行在内核态，处理器就执行一些内核例程。

Unix内核做的工作远不止处理系统调用。实际上，可以有几种方式激活内核例程：

- 进程调用系统调用。
- 正在执行进程的CPU发出一个异常(exception)信号，异常是一些反常情况，例如一个无效的指令。内核代表产生异常的进程处理异常。
- 外围设备向CPU发出一个中断(interrupt)信号以通知一个事件的发生，如一个要 求注意的请求、一个状态的变化或一个I/O操作已经完成等。每个中断信号都是由内核中的中断处理程序(interrupt handler)来处理的。因为外围设备与CPU异步操作，因此，中断在不可预知的时间发生。
- 内核线程被执行。因为内核线程运行在内核态，因此必须认为其相应程序是内核的一部分。

#### 进程实现

为了让内核管理进程，每个进程由一个进程描述符(process descriptor)表示，这个描述符包含有关进程当前状态的信息。
当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括：

- 程序计数器(PC) 和 栈指针(SP)寄存器
- 通用寄存器
- 浮点寄存器
- 包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word)
- 用来跟踪进程对RAM访问的内存管理寄存器

当内核决定恢复执行一个进程时，它用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。

当一个进程不在CPU上执行时，它正在等待某一事件。Unix内核可以区分很多等待状态，这些等待状态通常由进程描述符队列实现。每个(可能为空)队列对应一组等待特定事件的进程。

#### 可重入内核

所有的Unix内核都是可重入的(reentrant)，这意味着若干个进程可以同时在内核态下执行。当然，在单处理器系统上只有一个进程在真正运行，但是有许多进程可能在等待CPU或某一I/O操作完成时在内核态下被阻塞。例如，当内核代表某一进程发出一个读磁盘请求后，就让磁盘控制器处理这个请求并且恢复执行其他进程。当设备满足了读请求时，有一个中断就会通知内核，从而以前的进程可以恢复执行。

提供可重入的一种方式是编写函数，以便这些函数只能修改局部变量，而不能改变全局数据结构，这样的函数叫可重入函数。但是可重入内核不仅仅局限于这样的可重入函数(尽管一些实时内核正是如此实现的)。相反，可重入内核可以包含非重入函数，并且利用锁机制保证一次只有一个进程执行一个非重人函数。

如果一个硬件中断发生，可重入内核能挂起当前正在执行的进程，即使这个进程处于内核态。这种能力是非常重要的，因为这能提高发出中断的设备控制器的吞吐量。一旦设备已发出一个中断，它就一直等待直到CPU应答它为止。如果内核能够快速应答，设备控制器在CPU处理中断时就能执行其他任务。

现在，让我们看一下内核的可重入性及它对内核组织的影响。内核控制路径(kernel control path)表示内核处理系统调用、异常或中断所执行的指令序列。在最简单的情况下，CPU从第一条指令到最后一条指令顺序地执行内核控制路径。然而，当下述事件之一发生时，CPU交错执行内核控制路径：

- 运行在用户态下的进程调用一个系统调用，而相应的内核控制路径证实这个请求无法立即得到满足，然后，内核控制路径调用调度程序选择一个新的进程投入运行。结果，进程切换发生。第一个内核控制路径还没完成，而CPU又重新开始执行其他的内核控制路径。在这种情况下，两条控制路径代表两个不同的进程在执行。
- 当运行一个内核控制路径时，CPU检测到一个异常(例如，访问一个不在RAM中的页)。第一个控制路径被挂起，而CPU开始执行合适的过程。在我们的例子中，这种过程能给进程分配一个新页，并从磁盘读它的内容。当这个过程结束时，第一个控制路径可以恢复执行。在这种情况下，两个控制路径代表同一个进程在执行。
- 当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断发生。第一个内核控制路径还没执行完，CPU开始执行另一个内核控制路径来处理这个中断。当这个中断处理程序终止时，第一个内核控制路径恢复。在这种情况下，两个内核控制路径运行在同一进程的可执行上下文中，所花费的系统CPU时间都算给这个进程。然而，中断处理程序无需代表这个进程运行。
- 在支持抢占式调度的内核中，CPU正在运行，而一个更高优先级的进程加入就绪队列，则中断发生。在这种情况下，第一个内核控制路径还没有执行完，CPU代表高优先级进程又开始执行另一个内核控制路径。只有把内核编译成支持抢占式调度之后，才可能出现这种情况。

下图显示了非交错的和交错的内核控制路径的几个例子。考虑以下三种不同的CPU状态：

- 在用户态下运行一个进程(User)
- 运行一个异常处理程序或系统调用处理程序(Excp)
- 运行一个中断处理程序(Intr)

![内核控制路径交错执行.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%86%85%E6%A0%B8%E6%8E%A7%E5%88%B6%E8%B7%AF%E5%BE%84%E4%BA%A4%E9%94%99%E6%89%A7%E8%A1%8C.jpg?raw=true)

#### 进程地址空间

每个进程运行在它的私有地址空间。在用户态下运行的进程涉及到私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈。

因为内核是可重入的，因此几个内核控制路径(每个都与不同的进程相关)可以轮流执行。在这种情况下，每个内核控制路径都引用它自己的私有内核栈。

尽管看起来每个进程访问一个私有地址空间，但有时进程之间也共享部分地址空间。在一些情况下，这种共享由进程显式地提出；在另外一些情况下，由内核自动完成共享以节约内存。

如果同一个程序(比如说编辑程序)由几个用户同时使用，则这个程序只被装人内存一次，其指令由所有需要它的用户共享。当然，其数据不被共享，因为每个用户将有独立的数据。这种共享的地址空间由内核自动完成以节省内存。

进程间也能共享部分地址空间，以实现一种进程间通信，这就是由System V引人并且已经被Linux支持的“共享内存”技术。
最后，Linux支持mmap()系统调用，该系统调用允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间。内存映射为正常的读写传送数据方式提供了另一种选择。如果同一文件由几个进程共享，那么共享它的每个进程地址空间都包含有它的内存映射。

#### 同步和临界区

实现可重入内核需要利用同步机制：如果内核控制路径对某个内核数据结构进行操作时被挂起，那么，其他的内核控制路径就不应当再对该数据结构进行操作，除非它已被重新设置成一致性(consistent)状态。否则，两个控制路径的交互作用将破坏所存储的信息。

当某个计算结果取决于如何调度两个或多个进程时，相关代码就是不正确的。我们说存在一种竟争条件(race condition)。
一般来说，对全局变量的安全访问通过原子操作(atomic operation)来保证。临界区(critical region)是这样的一段代码，进入这段代码的进程必须完成，之后另一个进程才能进入。

这些问题不仅出现在内核控制路径之间，也出现在共享公共数据的进程之间。几种同步技术已经被采用。以下将集中讨论怎样同步内核控制路径。

##### 非抢占式内核

在寻找彻底、简单地解决同步问题的方案中，大多数传统的Unix内核都是非抢占式的：当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们的访问都是安全的。

当然，内核态的进程能自愿放弃CPU，但是在这种情况下，它必须确保所有的数据结构都处于一致性状态。此外，当这种进程恢复执行时，它必须重新检查以前访问过的数据结构的值，因为这些数据结构有可能被改变。

如果内核支持抢占，那么在应用同步机制时，确保进入临界区前禁止抢占，退出临界区时启用抢占。

非抢占能力在多处理器系统上是低效的，因为运行在不同CPU上的两个内核控制路径本可以并发地访问相同的数据结构。
禁止中断单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启用中断。这种机制尽管简单，但远不是最佳的。如果临界区比较大，那么在一个相对较长的时间内持续禁止中断就可能使所有的硬件活动处于冻结状态。

此外，由于在多处理器系统中禁止本地CPU上的中断是不够的，所以必须使用其他的同步技术。

##### 信号量

广泛使用的一种机制是信号量(semaphore)，它在单处理器系统和多处理器系统上都有效。信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看成一个对象，其组成如下：

- 一个整数变量
- 一个等待进程的链表
- 两个原子方法:down()和up()

down()方法对信号量的值减1，如果这个新值小于0，该方法就把正在运行的进程加入到这个信号量链表，然后阻塞该进程(即调用调度程序)。up()方法对信号量的值加1,如果这个新值大于或等于0，则激活这个信号量链表中的一个或多个进程。

每个要保护的数据结构都有它自己的信号量，其初始值为1。当内核控制路径希望访问这个数据结构时，它在相应的信号量上执行down()方法。如果信号量的当前值不是负数，则允许访问这个数据结构。否则，把执行内核控制路径的进程加入到这个信号量的链表并阻塞该进程。当另一个进程在那个信号量上执行up()方法时，允许信号量链表上的一个进程继续执行。

##### 自旋锁

在多处理器系统中，信号量并不总是解决同步问题的最佳方案。系统不允许在不同CPU上运行的内核控制路径同时访问某些内核数据结构，在这种情况下，如果修改数据结构所需的时间比较短，那么，信号量可能是很低效的。为了检查信号量，内核必须把进程插入到信号量链表中，然后挂起它。因为这两种操作比较费时，完成这些操作时，其他的内核控制路径可能已经释放了信号量。在这些情况下，多处理器操作系统使用了自旋锁(spin lock)。自旋锁与信号量非常相似，但没有进程链表。当一个进程发现锁被另一个进程锁着时，它就不停地“旋转”，执行一个紧凑的循环指令直到锁打开。

当然，自旋锁在单处理器环境下是无效的。当内核控制路径试图访问一个上锁的数据结构时，它开始无休止循环。因此，内核控制路径可能因为正在修改受保护的数据结构而没有机会继续执行，也没有机会释放这个自旋锁。最后的结果可能是系统挂起。

##### 避免死锁

与其他控制路径同步的进程或内核控制路径很容易进入死锁(deadlock)状态。

只要涉及到内核设计，当所用内核信号量的数量较多时，死锁就成为一个突出问题。在这种情况下，很难保证内核控制路径在各种可能方式下的交错执行不出现死锁状态。有几种操作系统(包括Linux)通过按规定的顺序请求信号量来避免死锁。

#### 信号和进程间通信

Unix信号(signal)提供了把系统事件报告给进程的一种机制。每种事件都有自己的信号编号，通常用一个符号常量来表示，例如SIGTERM。有两种系统事件：

- 异步通告

  例如，当用户在终端按下中断键(通常为CTRL-C)时，即向前台进程发出中断信号SIGINT。

- 同步错误或异常

  例如，当进程访问内存非法地址时，内核向这个进程发送一个SIGSEGV信号。

POSIX标准定义了大约20种不同的信号，其中，有两种是用户自定义的，可以当作用户态下进程通信和同步的原语机制。一般来说，进程可以以两种方式对接收到的信号做出反应：

- 忽略该信号。

- 异步地执行一个指定的过程(信号处理程序)。

如果进程不指定选择何种方式，内核就根据信号的编号执行一个默认操作。五种可能的默认操作是：

- 终止进程。

- 将执行上下文和进程地址空间的内容写入一个文件(核心转储，core dump)，并终止进程。
- 忽略信号。
- 挂起进程。
- 如果进程曾被暂停，则恢复它的执行。

因为POSIX语义允许进程暂时阻塞信号，因此内核信号的处理相当精细。此外，SIGKILL和SIGSTOP信号不能直接由进程处理，也不能由进程忽略。

AT&T的Unix System V引入了在用户态下其他种类的进程间通信机制，很多Unix内核也采用了这些机制：信号量、消息队列及共享内存。它们被统称为System V lPC。

内核把它们作为IPC资源来实现：进程要获得一个资源，可以调用shmget(),semget()或msgget()系统调用。与文件一样，IPC资源是持久不变的，进程创建者、进程拥有者或超级用户进程必须显式地释放这些资源。

这里的信号量与本章“同步和临界区”一节中所描述的信号量是相似的，只是它们用在用户态下的进程中。消息队列允许进程利用msgsnd()及msgget()系统调用交换消息，msgsnd()表示把消息插入到指定的队列中，msgget()表示从队列中提取消息。

POSIX标准(IEEE Std 1003.1-2001)定义了一种基于消息队列的IPC机制，这就是所谓的POSIX消息队列。它们和System V IPC消息队列是相似的，但是，它们对应用程序提供一个更简单的基于文件的接口。

共享内存为进程之间交换和共享数据提供了最快的方式。通过调用shmget()系统调用来创建一个新的共享内存，其大小按需设置。在获得IPC资源标识符后，进程调用shmat()系统调用，其返回值是进程的地址空间中新区域的起始地址。当进程希望把共享内存从其地址空间分离出去时，就调用shmdt()系统调用。共享内存的实现依赖于内核对进程地址空间的实现。

#### 进程管理

Unix在进程和它正在执行的程序之间做出一个清晰的划分。fork()和_exit()系统调用分别用来创建一个新进程和终止一个进程，而调用exec()类系统调用则是装入一个新程序。当这样一个系统调用执行以后，进程就在所装入程序的全新地址空间恢复运行。

调用fork()的进程是父进程，而新进程是它的子进程。父子进程能互相找到对方，因为进程描述符包含有两个指针，一个直接指向它的父进程，另一个直接指向它的子进程。

实现fork()一种简单的方式就是将父进程的数据与代码都复制，并把这个拷贝赋予子进程。这会相当费时。当前依赖硬件分页单元的内核采用写时复制(Copy-On-Write)技术，即把页的复制延迟到最后一刻(也就是说，直到父或子进程需要时才写进页)。

_exit()系统调用终止一个进程。内核对这个系统调用的处理是通过释放进程所拥有的资源并向父进程发送SIGCHILD信号(默认操作为忽略)来实现的。

##### 任死进程(zombie process)

父进程如何查询其子进程是否终止了呢?wait4()系统调用允许进程等待，直到其中的一个子进程结束.它返回已终止子进程的进程标识符(Process ID,  PID)。

内核在执行这个系统调用时，检查子进程是否已经终止。引入僵死进程的特殊状态是为了表示终止的进程：父进程执行完wait4()系统调用之前，进程就一直停留在那种状态。系统调用处理程序从进程描述符字段中获取有关资源使用的一些数据；一旦得到数据，就可以释放进程描述符。当进程执行wait4()系统调用时如果没有子进程结束，内核就通常把该进程设置成等待状态，一直到子进程结束。

很多内核也实现了waitpid()系统调用，它允许进程等待一个特殊的子进程。其他wait4()系统调用的变体也是相当通用的。
在父进程发出wait4()调用之前，让内核保存子进程的有关信息是一个良好的习惯，但是，假设父进程终止而没有发出wait4()调用呢?这些信息占用了一些内存中非常有用的位置，而这些位置本来可以用来为活动着的进程提供服务。例如，很多shell允许用户在后台启动一个命令然后退出。正在运行这个shell命令的进程终止，但它的子进程继续运行。

解决的办法是使用一个名为init的特殊系统进程，它在系统初始化的时候被创建。当一个进程终止时，内核改变其所有现有子进程的进程描述符指针，使这些子进程成为init的孩子。init监控所有子进程的执行，并且按常规发布wait4()系统调用，其副作用就是除掉所有僵死的进程。

##### 进程组和登录会话

现代Unix操作系统引入了进程组(process group)的概念，以表示一种“作业(job)"的抽象。例如，为了执行命令行：

```shell
ls | sort | mort
```


Shell支持进程组，例如bash，为三个相应的进程ls,sort及more创建了一个新的组。shell以这种方式作用于这三个进程，就好像它们是一个单独的实体(更准确地说是作业)。每个进程描述符包括一个包含进程组ID的字段。每一进程组可以有一个领头进程(即其PID与这个进程组的ID相同的进程)。新创建的进程最初被插入到其父进程的进程组中。

现代Unix内核也引入了登录会话(login session)。非正式地说，一个登录会话包含在指定终端已经开始工作会话的那个进程的所有后代进程——通常情况下，登录会话就是shell进程为用户创建的第一条命令。进程组中的所有进程必须在同一登录会话中。一个登录会话可以让几个进程组同时处于活动状态，其中，只有一个进程组一直处于前台，这意味着该进程组可以访问终端，而其他活动着的进程组在后台。当一个后台进程试图访问终端时，它将收到SIGTTIN或SIGTTOUT信号。在很多shell命令中，用内部命令bg和fg把一个进程组放在后台或者前台。

#### 内存管理

内存管理是迄今为止Unix内核中最复杂的活动。

##### 虚拟内存

所有新近的Unix系统都提供了一种有用的抽象，叫虚拟内存(virtual memory)。虚拟内存作为一种逻辑层，处于应用程序的内存请求与硬件内存管理单元(Memory Management Unit,  MMU)之间。虚拟内存有很多用途和优点：

- 若干个进程可以并发地执行。
- 应用程序所需内存大于可用物理内存时也可以运行。
- 程序只有部分代码装入内存时进程可以执行它。
- 允许每个进程访问可用物理内存的子集。
- 进程可以共享库函数或程序的一个单独内存映像。
- 程序是可重定位的，也就是说，可以把程序放在物理内存的任何地方。
- 程序员可以编写与机器无关的代码，因为他们不必关心有关物理内存的组织结构。

虚拟内存子系统的主要成分是虚拟地址空间(virtual address space)的概念。进程所用的一组内存地址不同于物理内存地址。当进程使用一个虚拟地址时，内核和MMU协同定位其在内存中的实际物理位置。

现在的CPU包含了能自动把虚拟地址转换成物理地址的硬件电路。为了达到这个目标，把可用RAM划分成长度为4KB或8KB的页框(page frame)，并且引入一组页表来指定虚拟地址与物理地址之间的对应关系。这些电路使内存分配变得简单，因为一块连续的虚拟地址请求可以通过分配一组非连续的物理地址页框而得到满足。

##### 随机访问存储器(RAM)的使用

所有的Unix操作系统都将RAM毫无疑义地划分为两部分，其中若干兆字节专门用于存放内核映像(也就是内核代码和内核静态数据结构)。RAM的其余部分通常由虚拟内存系统来处理，并且用在以下三种可能的方面：

- 满足内核对缓冲区、描述符及其他动态内核数据结构的请求。
- 满足进程对一般内存区的请求及对文件内存映射的请求。
- 借助于高速缓存从磁盘及其他缓冲设备获得较好的性能。

每种请求类型都是重要的。但从另一方面来说，因为可用RAM是有限的，所以必须在请求类型之间做出平衡，尤其是当可用内存没有剩下多少时。此外，当可用内存达到临界阈值时，可以调用页框回收(page-frame-reclaiming)算法释放其他内存。

虚拟内存系统必须解决的一个主要问题是内存碎片。理想情况下，只有当空闲页框数太少时，内存请求才失败。然而，通常要求内核使用物理上连续的内存区域，因此，即使有足够的可用内存，但它不能作为一个连续的大块使用时，内存的请求也会失败。

##### 内核内存分配器

内核内存分配器(Kernel Memory Allocator, KMA)是一个子系统，它试图满足系统中所有部分对内存的请求。其中一些请求来自内核其他子系统，它们需要一些内核使用的内存，还有一些请求来自于用户程序的系统调用，用来增加用户进程的地址空间。一个好的KMA应该具有下列特点：

- 必须快。实际上，这是最重要的属性，因为它由所有的内核子系统(包括中断处理程序)调用。
- 必须把内存的浪费减到最少。
- 必须努力减轻内存的碎片(fragmentation)问题。
- 必须能与其他内存管理子系统合作，以便借用和释放页框。

基于各种不同的算法技术，已经提出了几种KMA，包括：

- 资源图分配算法(allocator)

- 2的幕次方空闲链表
- McKusick-Karels分配算法
- 伙伴(Buddy)系统
- Mach的区域(Zone)分配算法
- Dynix分配算法
- Solaris的Slab分配算法

Linux的KMA在伙伴系统之上采用了Slab分配算法。

##### 进程虚拟地址空间处理

进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址。内核通常用一组内存区描述符描述进程虚拟地址空间。例如，当进程通过exec()类系统调用开始某个程序的执行时，内核分配给进程的虚拟地址空间由以下内存区组成：

- 程序的可执行代码
- 程序的初始化数据
- 程序的未初始化数据
- 初始程序栈(即用户态栈)
- 所需共享库的可执行代码和数据
- 堆(由程序动态请求的内存)

所有现代Unix操作系统都采用了所谓请求调页(demand paging)的内存分配策略。有了请求调页，进程可以在它的页还没有在内存时就开始执行。当进程访问一个不存在的页时，MMU产生一个异常；异常处理程序找到受影响的内存区，分配一个空闲的页，并用适当的数据把它初始化。同理，当进程通过调用malloc()或brk()(由malloc()在内部调用)系统调用动态地请求内存时，内核仅仅修改进程的堆内存区的大小。只有试图引用进程的虚拟内存地址而产生异常时，才给进程分配页框。虚拟地址空间也采用其他更有效的策略，如前面提到的写时复制策略。例如，当一个新进程被创建时，内核仅仅把父进程的页框赋给子进程的地址空间，但是把这些页框标记为只读。一旦父或子进程试图修改页中的内容时，一个异常就会产生。异常处理程序把新页框赋给受影响的进程，并用原来页中的内容初始化新页框。

##### 高速缓存

物理内存的一大优势就是用作磁盘和其他块设备的高速缓存。这是因为硬盘非常慢：磁盘的访问需要数毫秒，与RAM的访问时间相比，这太长了。因此，磁盘通常是影响系统性能的瓶颈。通常，在最早的Unix系统中就已经实现的一个策略是：尽可能地推迟写磁盘的时间，因此，从磁盘读入内存的数据即使任何进程都不再使用它们，它们也继续留在RAM中。
这一策略的前题是有好机会摆在面前：新进程请求从磁盘读或写的数据，就是被撤消进程曾拥有的数据。当一个进程请求访问磁盘时，内核首先检查进程请求的数据是否在缓存中，如果在(把这种情况叫做缓存命中)，内核就可以为进程请求提供服务而不用访问磁盘。

sync()系统调用把所有“脏”的缓冲区(即缓冲区的内容与对应磁盘块的内容不一样)写入磁盘来强制磁盘同步。为了避免数据丢失，所有的操作系统都会注意周期性地把脏缓冲区写回磁盘。

#### 设备驱动程序

内核通过设备驱动程序(device driver)与I/O设备交互。设备驱动程序包含在内核中，由控制一个或多个设备的数据结构和函数组成，这些设备包括硬盘、键盘、鼠标、监视器、网络接口及连接到SCSI总线上的设备。通过特定的接口，每个驱动程序与内核中的其余部分(甚至与其他驱动程序)相互作用这种方式具有以下优点：

- 可以把特定设备的代码封装在特定的模块中。
- 厂商可以在不了解内核源代码而只知道接口规范的情况下，就能增加新的设备。
- 内核以统一的方式对待所有的设备，并且通过相同的接口访问这些设备。
- 可以把设备驱动程序写成模块，并动态地把它们装进内核而不需要重新启动系统。
- 不再需要时，也可以动态地卸下模块，以减少存储在RAM中的内核映像的大小。

下图说明了设备驱动程序与内核其他部分及进程之间的接口。

![设备驱动程序接口.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3.jpg?raw=true)

一些用户程序(P)希望操作硬件设备。这些程序就利用常用的、与文件相关的系统调用及在/dev目录下能找到的设备文件向内核发出请求。实际上，设备文件是设备驱动程序接口中用户可见的部分。每个设备文件都有专门的设备驱动程序，它们由内核调用以执行对硬件设备的请求操作。

这里值得一提的是，在Unix刚出现的时候，图形终端是罕见而且昂贵的，因此Unix内核只直接处理字符终端。当图形终端变得非常普遍时，一些如XWindow系统那样的特别的应用就出现了，它们以标准进程的身份运行，并且能直接访问图形界面的I/O端口和RAM的视频区域。一些新近的Unix内核，例如Linux 2.6，对图形卡的帧缓冲提供了一种抽象，从而允许应用软件无需了解图形界面的I/O端口的任何知识就能对其进行访问。

## 第2章 内存寻址

### 内存地址

逻辑地址（logical address）：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。这种寻址方式在80x86著名的分段结构中表现的尤为具体，它促使MS-DOS或Windows程序员把程序分成若干段。

线性地址（linear address）（或 虚拟地址 virtual address）：一个32位无符号整数，可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 * 1024 * 1024 * 1024个内存单元（字节）。

物理地址（physical address）：芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。

内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。

在多处理器系统中，所有CPU都共享同一内存。这意味着RAM芯片可以由独立的CPU并发地访问。因为在RAM芯片上的读或写操作必须串行地执行，因此一种所谓内存仲裁器(memory arbiter)的硬件电路插在总线和每个RAM芯片之间。其作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含一个叫做 DMA控制器 的特殊处理器，而DMA控制器与CPU并发操作（RAM）。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如，双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。从编程观点看，因为仲裁器由硬件电路管理，因此它是隐藏的。

### 硬件中的分段

80286之前仅有实模式：数据总线 16位，地址总线20位，寄存器16位。

从80286模型开始，Intel微处理器以两种不同的方式执行地址转换：实模式（real mode）和保护模式（protected mode）（数据总线、地址总线32位，寄存器32位）。实模式存在的主要原因是要维持处理器与早期模型兼容，并让操作系统自举。

#### 段选择符和段寄存器

一个逻辑地址由两部分组成：段标识符和指定段内相对地址的偏移量。段标识符是一个16位长的字段，称为段选择符（Segment Selector），而偏移量是一个32位长的字段。



![段选择符.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true)

为了快速方便地找到段选择符，处理器提供段寄存器，段寄存器的唯一目的是 存放段选择符。这些段寄存器称为cs,  ss, ds, es,  fs和gs。尽管只有6个段寄存器，但程序可以把同一个段寄存器用于不同的目的，方法是先将其值保存在内存中，用完后再恢复。
6个段寄存器中3个有专门的用途：
cs	代码段寄存器，指向包含程序指令的段。
ss	栈段寄存器，指向包含当前程序栈的段。
ds	数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。
其他3个段寄存器作一般用途，可以指向任意的数据段。
cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。值为0代表最高优先级，而值为3代表最低优先级。Linux只用0级和3级，分别称之为内核态和用户态。

#### 段描述符

每个段由一个 8字节 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。

通常只定义一个GDT，而每个进程除了存放在GDT中段之外如果还需要创建附加的段，就可以有自己的LDT。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。

![段描述符通用格式.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.jpg?raw=true)

![几种段描述符格式.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%87%A0%E7%A7%8D%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A0%BC%E5%BC%8F.jpg?raw=true)

| 字段名   | 描述                                       |
| ----- | ---------------------------------------- |
| Base  | 包含段的首字节的线性地址 （32 bit）                    |
| G     | 粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计         |
| Limit | 存放段中最后一个内存单元的偏移量，从而决定段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化 |
| S     | 系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段 |
| Type  | 描述了段的类型特征和它的存取权限                         |
| DPL   | 描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级 |
| P     | Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去 |
| D或B   | 取决于是代码段还是数据段                             |
| AVL   | 操作系统使用，但被Linux忽略                         |

代码段和数据段描述符类型如下表：

![代码段和数据段描述符类型.png](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B.png?raw=true)

代码段描述符：代表一个代码段，它可以放在GDT或LDT中。该描述符置S标志为1(非系统段)。

数据段描述符：代表一个数据段，它可以放在GDT或LDT中。该描述符置S标志为1。栈段是通过一般的数据段实现的。

任务状态段描述符（TSSD）：代表一个任务状态段(Task State Segment, TSS )，也就是说这个段用于保存处理器寄存器的内容。它只能出现在GDT中。根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。这个描述符的S标志置为0。

局部描述符表描述符（LDTD）：代表一个包含LDT的段，它只出现在GDT中。相应的Type字段的值为2，S标志置为0。

段选择符字段：

| 字段名   | 描述                                       |
| ----- | ---------------------------------------- |
| index | 指定了放在GDT或LDT中的相应段描述符的入口                  |
| TI    | TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） |
| RPL   | 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 |

#### 快速访问段描述符

重申：逻辑地址由16位段选择符和32位偏移量组成，段寄存器仅仅存放段选择符。

为了加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。

![段选择符和段描述符.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6%E5%92%8C%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg?raw=true)

由于一个段描述符是8字节，因此它在GDT或LDT内的相对地址是由段选择符的最高13位（index）的值乘以8得到的。例如：如果GDT在0x0002 0000（这个值保存在gdtr寄存器中），且由段选择符所指定的索引号为2，那么相应的段描述符地址是0x0002 0000 + (2 * 8)，或0x0002 0010。

GDT的第一项总是设为0。这就确保空段选择符的逻辑地址会被认为是无效的，因此引起一个处理器异常。能够保存在GDT中的段描述符的最大数目是8191，即2^13^ - 1。

#### 分段单元

下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作：

- 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。
- 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。
- 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。

![逻辑地址转换.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.jpg?raw=true)

有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。

### Linux中的分段

分段使程序划分成逻辑上相关的实体，例如子程序或者全局与局部数据区。然而，Linux以非常有限的方式使用分段。实际上，分段和分页在某种程度上有点多余因为它们都可以划分进程的物理地址空间：分段可以给每个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理地址空间（页表映射不同）。与分段相比，Linux更喜欢用分页的方式：

- 当所有的进程使用相同的段寄存器值时，内存管理变得更简单，也就是它们能共享同样的一组线性地址。
- Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持有限。

2.6版的Linux只有在x86结构下才需要分段。

运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址:它们分别叫做内核代码段和内核数据段。

下表显示了这4个重要段的段描述符字段的值：

| 段     | Base        | G    | Limit   | S    | Type | DPL  | D/B  | p    |
| ----- | ----------- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |
| 用户代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 3    | 1    | 1    |
| 用户数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 3    | 1    | 1    |
| 内核代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 0    | 1    | 1    |
| 内核数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 0    | 1    | 1    |

G为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB

相应的段选择符由宏定义。

```c
  __USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS
```

为了对内核代码段寻址，内核只需把\_\_KERNEL_CS宏产生的值装进cs段寄存器即可。

注意，与段相关的线性地址从0开始，达到2^23^ - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。

所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。

如前所述，CPU的当前特权级(CPL)反映了进程是在用户态还是内核态，并由存放在cs寄存器中的段选择符的RPL字段指定。只要当前特权级被改变，一些段寄存器必须相应地更新。例如，当CPL=3时(用户态)，ds寄存器必须含有用户数据段的段选择符，而当CPL=0时，ds寄存器必须含有内核数据段的段选择符。

类似的情况也出现在ss寄存器中。当CPL为3时，它必须指向一个用户数据段中的用户栈，而当CPL为0时，它必须指向内核数据段中的一个内核栈。当从用户态切换到内核态时，Linux总是确保ss寄存器装有内核数据段的段选择符。

当对指向指令或者数据结构的指针进行保存时，内核根本不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏\_\_KERNEL_CS定义，所以只要当CPU切换到内核态时将\_\_KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。

#### Linux GDT

在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。如果你到源代码索引中查看，可以看到这些符号都在文件arch/i386/kernel/head.S中被定义。

下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。

![全局描述符表.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg?raw=true)

每一个GDT中包含的18个段描述符指同下列的段：

- 用户态和内核态下的代码段和数据段，共4个。
- 任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb,  因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置    为0，因为不允许用户态下的进程访问TSS段。
- 1个包括缺省局部描述符表的段，这个段通常被所有进程共享。
- 3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。
- 与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。
- 与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。
- 被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。

系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项：

- 每个处理器都有它自己的TSS段。
- GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。
- 在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。

#### Linux LDT

大多数用户态下的Linux程序不使用局部描述符表，这样内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。

在某些情况下，进程仍然需要创建自己的LDT，像Wine那样的程序，它们执行面向段的微软Windows应用程序。modify_ldt()系统调用允许进程创建自己的LDT。任何被modify_ldt()创建的自定义局部描述符表仍然需要它自己的段。当处理器开始执行拥有自定义局部描述符表的进程时，该CPU的GDT副本中的LDT表项相应地就被修改了。

用户态下的程序同样也利用modify_ldt()来分配新的段，但内核却从不使用这些段，它也不需要了解相应的段描述符，因为这些段描述符被包含在进程自定义的局部描述符表中了。

### 硬件中的分页

分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。

为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。

分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。

把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。

从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。<需要了解控制寄存器(cr0~cr3)的结构及作用>

#### 常规分页

从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域：

- Directory（目录）：最高10位
- Table（页表）：中间10位
- Offset（偏移量）：最低12位

线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )(小写的‘page table’表示保存线性地址和物理地址之间映射的页，而利用‘Page Table’表示在上层页表中的页)。

页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。

使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2^20^个表项(也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存容量。

每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。

正在使用的页目录的物理地址存放在控制寄存器cr3中。线性地址内的Directory字段决定页目录中的目录项，而目录项指向适当的页表。地址的Table字段依次又决定页表中的表项，而表项含所有页所在页框的物理地址。Offset字段决定页框内的相对位置。由于它是12位长，故每一页含有4096字节的数据。

![x86处理器的分页.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/x86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E9%A1%B5.jpg?raw=true)

Directory字段和Table字段都是10位长，因此页目录和页表都可以多达1024项。那么一个页目录可以寻址到高达1024 * 1024 * 4096 = 2^32^个存储单元，这和你对32位地址所期望的一样。

页目录项和页表项有相同的结构，每项都包含下面的字段：

| 字段                | 描述                                       |
| ----------------- | ---------------------------------------- |
| Present标志         | 置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。 |
| 包含页框物理地址最高20位的字段  | 由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。 |
| Accessed标志        | 每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。 |
| Dirty标志           | 只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。 |
| Read/Write标志      | 含有页或页表的存取权限。                             |
| User/Supervisor标志 | 含有访问页或页表所需的特权级。                          |
| PCD和PWT标志         | 控制硬件高速缓存处理页或页表的方式。                       |
| Page Size标志       | 只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。          |
| Global标志          | 只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。 |

#### 扩展分页

从Pentium模型开始，80x86微处理器引入了扩展分页（extended paeging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。

通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段：

- Directory：最高10位
- Offset：其余22位

扩展分页和正常分页的目录项基本相同，除了：

- Page Size标志必须被设置。
- 20位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。<32位物理地址还是20位物理地址？>

通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。

#### 硬件保护方案

分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。

此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。

#### 常规分页举例

假定内核已给一个正在允许的进程分配的线性地址空间范围是0x2000 0000 到 0x2003 ffff。这个空间正好由64页组成。从分配给进程的线性地址的最高10位（Directory字段）开始。这两个地址都以2开头后面跟着0，因此高10位有相同的值，即0x080或十进制128。因此，这两个地址的Directory字段都指向进程页目录的第129项。相应的目录项中必须包含分配给该进程的页表的物理地址。如果没有给这个进程分配其他的线性地址，则页目录的其余1023项都填为0.

中间10位的值（Table）范围从0到0x03f，十进制的0到63，因而只有页表的前64个表项是有意义的，其余960个表项都填0。

假设进程需要读取线性地址 0x2002 1406中的字节，则处理方法：

1. Directory字段的0x80用于选择页目录的第0x80目录项，此目录项指向和该进程的页相关的页表。
2. Table字段0x21用于选择页表的第0x21表项，此表项指向包含所需页的页框。
3. 最后，Offset字段0x406用于在目标页框中读偏移量为0x406中的字节。

如果页表第0x21表项的Present标志为0，则此页就不在主存中，这种情况下，分页单元在线性地址转换的同时产生一个缺页异常。无论何时，当进程试图访问限定在0x2000 0000 到 0x2003 ffff范围之外的线性地址时，都将产生一个缺页异常，因为这些页表项都填充了0，尤其是它们的Present标志都被清0。

#### 物理地址扩展（PAE）分页机制

处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址，我们将会在后而"Linux中的分页”一节中看到这一点。

然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到2^36^ = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。

从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。

通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。

Intel为了支持PAE已经改变了分页机制：

- 64GB的RAM被分为2^24^个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。
- 引入一个叫做页目录指针表(Page Directory Pointer Table,  PDPT)的页表新级别，它由4个64位表项组成。
- cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(2^5^)的倍数上对齐，因此27位足以表示这种表的基地址。
- 当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释：
  - cr3：指向一个PDPT
  - 位31-30：指向PDPT中4个项中的一个
  - 位29-21：指向页目录中512个项目中的一个
  - 位20-12：指向页表中512项中的一个
  - 位11-0：4KB页中的偏移量
- 当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释：
  - cr3：指向一个PDPT
  - 位31-30：指向PDPT中4个项中的一个
  - 位29-21：指向页目录中512个项中的一个
  - 位20-0：2MB页中的偏移量

总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。

#### 64位系统中的分页

32位微处理器普遍采用两级分页。然而两级分页并不适用于采用64位系统的计算机。让我们用一种思维实验来解释为什么：首先假设一个大小为4KB的标准页。因为1KB覆盖2^10^个地址的范围，4KB覆盖2^12^个地址，所以offset字段是12位。这样线性地址就剩下52位分配给Table和Directory字段。如果我们现在决定仅仅使用64位中的48位来寻址(这个限制仍然使我们自在地拥有256TB的寻址空间！)，剩下的48-12=36位将被分配给Table和Directory字段。如果我们现在决定为两个字段各预留18位，那么每个进程的页目录和页表都含有2^18^个项，即超过256000个项。

由于这个原因，所有64位处理器的硬件分页系统都使用了额外的分页级别。使用的级别数量取决于处理器的类型。

| 平台名称   | 页大小  | 寻址使用的位数 | 分页级别数 | 线性地址分级      |
| ------ | ---- | ------- | ----- | ----------- |
| alpha  | 8KB  | 43      | 3     | 10+10+10+13 |
| ia64   | 4KB  | 39      | 3     | 9+9+9+12    |
| ppc64  | 4KB  | 41      | 3     | 10+10+9+12  |
| sh64   | 4KB  | 41      | 3     | 10+10+9+12  |
| x86_64 | 4KB  | 48      | 4     | 9+9+9+9+12  |

#### 硬件高速缓存

当今的微处理器时钟频率接近几个GHz，而动态RAM（DRAM）芯片的存取时间是时钟周期的数百倍。这意味着，当从RAM中取操作数或向RAM中存放结果这样的指令执行时，CPU可能等待很长时间。

为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory )。硬件高速缓存基于著名的 局部性原理(locality principle)，该原理既适用程序结构也适用数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。因此，引入小而快的内存来存放最近最常使用的代码和数据变得很有意义。为此，x86体系结构中引入了一个叫 行(line)的新单位。行由几十个连续的字节组成，它们以脉冲突发模式(burst mode)在慢速DRAM和快速的用来实现高速缓存的片上静态RAM ( SRAM)之间传送，用来实现高速缓存。

高速缓存再被细分为行的子集。在一种极端的情况下，高速缓存可以是直接映射的(direct mapped)，这时主存中的一个行总是存放在高速缓存中完全相同的位置。在另一种极端情况下，高速缓存是充分关联的(fully  associative)，这意味着主存中的任意一个行可以存放在高速缓存中的任意位置。但是大多数高速缓存在某种程度上是N-路组关联的(N-way set associative)，意味着主存中的任意一个行可以存放在高速缓存N行中的任意一行中。例如，内存中的一个行可以存放到一个2路组关联高速缓存两个不同的行中。

![处理器硬件高速缓存.png](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%A4%84%E7%90%86%E5%99%A8%E7%A1%AC%E4%BB%B6%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png?raw=true)

高速缓存单元插在分页单元和主内存之间。它包含一个硬件高速缓存内存(hardware cache memory)和一个高速缓存控制器(cache controller) 。高速缓存内存存放内存中真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签（tag）和描述高速缓存行状态的几个标志（flag）。这个标签由一些位组成，这些位让高速缓存控制器能够辨别由这个行当前所映射的内存单元。这种内存物理地址通常分为3组:最高几位对应标签，中间几位对应高速缓存控制器的子集索引，最低几位对应行内的偏移量。

当访问一个RAM存储单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(cache hit);否则，高速缓存没有命中(cache miss )。

当命中一个高速缓存时，高速缓存控制器进行不同的操作，具体取决于存取类型。对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器;不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了其应有的作用。对于写操作，控制器可能采用以下两个基本策略之一，分别称之为通写（write-through）和回写(write-back)。在通写中，控制器总是既写RAM也写高速缓存行，为了提高写操作的效率关闭高速缓存。回写方式只更新高速缓存行，不改变RAM的内容，提供了更快的功效。当然，回写结束以后，RAM最终必须被更新。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时(通常在高速缓存不命中之后)，高速缓存控制器才把高速缓存行写回到RAM中。

当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存的表项中。

多处理器系统的每一个处理器都有个单独的硬件高速缓存，因此它们去要额外的硬件电路用于保持高速缓存内容的同步。每个CPU都有自己的本地硬件高速缓存。但是，现在更新变得更耗时:只要一个CPU修改了它的硬件高速缓存，它就必须检查同样的数据是否包含在其他的硬件高速缓存中;如果是，它必须通知其他CPU用适当的值对其更新。常把这种活动叫做高速缓存侦听（cache snooping）。所有这一切都在硬件级处理，内核无需关心。

处理器的cr0寄存器的CD标志位用来启用或禁用高速缓存电路。这个寄存器中的NW标志指明高速缓存是使用通写还是回写策略。

Pentium处理器高速缓存的另一个有趣的特点是，让操作系统把不同的高速缓存管理策略与每一个页框相关联。为此，每一个页目录项和每一个页表项都包含两个标志：PCD(Page Cache Disablt)标志指明当访问包含在这个页框中的数据时，高速缓存功能必须被启用还是禁用。PWT(page Write-Through)标志指明当把数据写到页框时，必须使用的策略是回写策略还是通写策略。Linux清除了所有页目录项和页表项中的PCD和PWT标志；结果是：对于所有的页框都启用高速缓存，对于写操作总是采用回写策略。

#### 转换后援缓冲器（TLB）

除了通用硬件高速缓存之外，x86处理器还包含了另一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。

在多处理系统中，每个CPU都有自己的TLB，这叫做该CPU的本地TLB。与硬件高速缓存相反，TLB中的对应项不必同步，这是因为运行在现有CPU上的进程可以使同一线线性地址与不同的物理地址发生联系。

当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。

### Linux中的分页

Linux采用了一种同时适用于32位和64位系统的普通分页模型。正像前面所解释的那样，两级页表对32位系统来说已经足够了，但64位系统需要更多数量的分页级别。直到2.6.10版本，Linux采用三级分页的模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为：

- 页全局目录(Page Global Directory )
- 页上级目录(Page Upper Directory )
- 页中级目录(Page Middle Directory )
- 页表(Page Table)

![Linux分页模式.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F.jpg?raw=true)

页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。每一部分的大小与具体的计算机体系结构有关。

对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。

启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。

最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。

Linux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：

- 给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。
- 区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。

每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。

把线性地址映射到物理地址虽然有点复杂，但现在已经成了一种机械式的任务。下面会列举一些函数和宏，它们检索内核为了查找地址和管理表格所需的信息；其中大多数函数只有一两行。

#### 线性地址字段

下列宏简化了页表处理。

| 宏名                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| PAGE_SHIFT                               | 指定Offset字段的位数；当用于x86处理器时，它产生的值为12。由于页内所有地址都必须能放到Offset字段中，因此x86系统的页的大小是2^12^=4096字节。 |
| PMD_SHIFT                                | 指定线性地址的Offset字段和Table字段的总位数。换句话说，是页中间目录项可以映射的区域大小的对数。PMD_SIZE宏用于计算由页中间目录的一个单独表项所映射的区域大小，也就是一个页表的大小。PMD_MASK宏用于屏蔽Offset字段与Table字段的所有位。当PAE被禁用时，PMD_SHIFT产生的值为22(来自Offset的12位加上来自Table的10位)，PMD_SIZE产生的值为2^22^或4 MB , PMD_MASK产生的值为0xffc000000相反，当PAE被激活时，PMD_SHIFT产生的值为21(来自Offset的12位加上来自Table的9位)，PMD_SIZE产生的值为2^21^或2 MB,  PMD_MASK产生的值为0xffe00000。大型页不使用最后一级页表，所以产生大型页尺寸的LARGE_PAGE_SIZE宏等于PMD_SIZE(2PMD_SHIFT)，而在大型页地址中用于屏蔽Offset字段和Table字段的所有位的LARGE_PAGE_MASK宏，就等于PMD_MASK。 |
| PUD_SHIFT                                | 确定页上级目录项能映射的区域大小的对数。PUD_SIZE宏用于计算页全局目录中的一个单独表项所能映射的区域大小。PUD_ MASK宏用于屏蔽Offset字段、Table字段、Middle Air字段和Upper Air字段的所有位。在x86处理器上，PUD_SHIFT总是等价于PMD_SHIFT，而PUD_SIZE则等于4MB或2MB。 |
| PGDIR_SHIFT                              | 确定页全局目录项能映射的区域大小的对数。PGDIR_SIZE宏用于计算页全局目录中一个单独表项所能映射区域的大小。PGDIR_MASK宏用于屏蔽Offset, Table, Middle Air及Upper Air字段的所有位。当PAE被禁止时，PGDIR_SHIFT产生的值为22(与PMD-SHIFT和PUD_SHIFT产生的值相同)，PGDIR_SIZE产生的值为2^22^或4MB，以及PGDIR_MASK产生的值为0xffc00000。相反，当PAE被激活时，PGDIR_SHIFT产生的值为30(12位Offset加9位Table再加9位Middle Air)，PGD工R_S工ZE产生的值为2^30^或1 GB以及PGDIR_ MASK产生的值为0xc0000000。 |
| PTRS_PER_PTE  PTRS_PER_PMD PTRS_PER_PUD PTRS_PER_PGD | 用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当PAE被禁止时，它们产生的值分别为1024,1,1和1024。当PAE被激活时，产生的值分别为512,512,1和4。 |

#### 页表处理

pte_t, pmd_t, pud_t和pgd_t分别描述页表项、页中间目录项、页上级目录和页全局目录项的格式。当PAE被激活时它们都是64位的数据类型，否则都是32位数据类型。pgprot_t是另一个64位(PAE激活时)或32位(PAE禁用时)的数据类型，它表示与一个单独表项相关的保护标志。

五个类型转换宏(\_\_pte、\_\_pmd、\_\_pud、\_\_pgd和__pgprot)把一个无符号整数转换成所需的类型。另外的五个类型转换宏(pte_val, pmd_val, pud_val, pgd_val和pgprot_val)执行相反的转换，即把上面提到的四种特殊的类型转换成一个无符号整数。
内核还提供了许多宏和函数用于读或修改页表表项：

- 如果相应的表项值为0，那么，宏pte_none, pmd_none, pud_none和pgd_none产生的值为1，否则产生的值为0。
- 宏pte_clear, pmd_clear, pud_clear和pgd_clear清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。ptep_get and_clear()函数清除一个页表项并返回前一个值。
- set_pte, set_pmd, set_pud和 set_pgd向一个页表项中写入指定的值。set_pte_atomic与set_pte的作用相同，但是当PAE被激活时它同样能保证64位的值被原子地写入。
- 如果a和b两个页表项指向同一页并且指定相同的访问优先级，那么pte_same(a,b)返回1，否则返回0。
- 如果页中间目录项e指向一个大型页(2MB或4MB )，那么pmd_large(e)返回1，否贝返回0。

宏pmd_bad由函数使用并通过输入参数传递来检查页中间目录项。如果目录项指向一个不能使用的页表，也就是说，如果至少出现以下条件中的一个，则这个宏产生的值为1：

- 页不在主存中(Present标志被清除)。
- 页只允许读访问(Read/Write标志被清除)。
- Acessed或者Dirty位被清除(对于每个现有的页表，Linux总是强制设置这些 标志)。

宏pud_bad和pgd_bad总是产生0。没有定义pte_bad宏，因为页表项引用一个不在主存中的页、一个不可写的页或一个根本无法访问的页都是合法的。

如果一个页表项的Present标志或者Page Size标志等于1，则pte_present宏产生的值为1，否则为0。前面讲过页表项的Page Size标志对微处理器的分页单元来讲没有意义，然而，对于当前在主存中却又没有读、写或执行权限的页，内核将其Present和Page Size分别标记为0和1。这样，任何试图对此类页的访问都会引起一个缺页异常，因为页的Present标志被清0，而内核可以通过检查Page Size的值来检测到产生异常并不是因为缺页。

如果相应表项的Present标志等于1，也就是说，如果对应的页或页表被载入主存，pmd_present宏产生的值为1。pud_present宏和pgd_present宏产生的值总是1。

下表列出的函数用来查询页表项中任意一个标志的当前值；除了pte_file()外，其他函数只有在pte_present返回1的时候，才能正常返回页表项中任意一个标志。

| 函数名称                       | 说明                                       |
| -------------------------- | ---------------------------------------- |
| pte_user()                 | 读User/Supervisor标志                       |
| pte_read()                 | 读User/Supervisor标志（x86处理器上的页不受读的保护）      |
| pte_write()                | 读Read/Write标志                            |
| pte_exec()                 | 读User/Supervisor标志（x86处理器上的页不受代码执行的保护）   |
| pte_dirty()                | 读Dirty标志                                 |
| pte_young()                | 读Accessed标志                              |
| pte_file()                 | 读Dirty标志（当Present标志被清除而Dirty标志被设置时，页属于一个非线性磁盘文件映射） |
| mk_pte_huge()              | 设置页表项中的Page Size和Present标志               |
| pte_wrprotect()            | 清除Read/Write标志                           |
| pte_rdprotect()            | 清除User/Supervisor标志                      |
| pte_exprotect()            | 清除User/Supervisor标志                      |
| pte_mkwrite()              | 设置Read/Write标志                           |
| pte_mkread()               | 设置User/Supervisor标志                      |
| pte_mkexec()               | 设置User/Supervisor标志                      |
| pte_mkclean()              | 清除Dirty标志                                |
| pte_mkdirty()              | 设置Dirty标志                                |
| pte_mkold                  | 清除Accessed标志（此页标记为未访问）                   |
| pte_mkyoung                | 设置Accessed标志（此页标记为访问过）                   |
| pte_modify(p, v)           | 把页表项p的所有访问权限设置为指定的值v                     |
| ptep_set_wrprotect()       | 类似pre_wrprotect()，但作用于指向页表项的指针           |
| ptep_set_access_flags()    | 如果Dirty标志被设置为1，则将页的存取权限设置为指定的值，并调用flush_tlb_page()函数。 |
| ptep_mkdirty()             | 类似pte_mkdirty()，但作用于指向页表项的指针             |
| pte_test_and_clear_dirty() | 类似pte_mkclean()，但作用于指向页表项的指针并返回Dirty标志的旧值 |
| pte_test_and_clear_young() | 类似pte_mkold()，但作用于指向页表项的指针并返回Accessed标志的旧值 |

下表为一些宏，它们把一个页地址和一组保护标志组合成页表项，或者执行相反的操作，从一个页表项中提取出页地址。注意这其中一些宏对页的引用是通过“页描述符”（mm_struct）的线性地址，而不是通过该页本身的线性地址。

| 宏名称                         | 说明                                       |
| --------------------------- | ---------------------------------------- |
| pgd_index(addr)             | 找到线性地址addr对应的目录项在页全局目录中的索引（相对位置）         |
| pgd_offset(mm,addr)         | 以内存描述符和线性地址作为参数。产生地址addr在页全局目录中相应表项的线性地址；通过内存描述符mm内的一个指针可以找到这个页全局目录 |
| pgd_offset_k(addr)          | 产生主内核页全局目录中的某个项的线性地址，该项                  |
| pgd_page(pgd)               | 通过页全局目录项pgd产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于pud_page()，后者应用于页上级目录项 |
| pud_offset(pgd,addr)        | 接收指向页全局目录项的指针pgd和线性地址addr作为参数。这个宏产生页上级目录中目录项addr对应的线性地址。在两级或三级分页系统中，该宏产生pgd，即一个页全局目录项的地址 |
| pud_page(pud)               | 通过页上级目录项pud产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于pmd_page() ,后者应用于页中间目录项 |
| pmd_index(addr)             | 产生线性地址addr在页中间目录中所对应目录项的索引(相对位置)         |
| pmd_offset(pud,addr)        | 接收指向页上级目录项的指针pud和线性地址addr作为参数。这个宏产生目录项addr在页中间目录中的偏移地址。在两级或三级分页系统中，它产生pud，即页全局目录项的地址 |
| pmd_page(pmd)               | 通过页中间目录项pmd产生相应页表的页描述符地址。在两级或三级分页系统中，pmd实际上是页全局目录中的一项 |
| mk_pte(p,prot)              | 接收页描述符地址P和一组存取权限prot作为参数，并创建相应的页表项       |
| pte_index(addr)             | 产生线性地址addr对应的表项在页表中的索引(相对位置)             |
| pte_offset_kernel(dir,addr) | 线性地址addr在页中间目录dir中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用 |
| pte_offset_map(dir,addr)    | 接收指向一个页中间目录项的指针dir和线性地址addr作为参数，它产生与线性地址addr相对应的页表项的线性地址。如果页表被保存在高端内存中，那么内核建立一个临时内核映射，并用pte_unmap对它进行释放。pte_offset_map_nested宏和pte_unmap_nested宏是相同的，但它们使用不同的临时内核映射 |
| pte_page(x)                 | 返回页表项x所引用页的描述符地址                         |
| pte_to_pgoff(pte)           | 从一个页表项的pte字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页 |
| pgoff_to_pte(offset)        | 为非线性文件内存映射所在的页创建对应页表项的内容                 |

下表罗列最后一组函数来简化页表项的创建和撤消。

当使用两级页表时，创建或删除一个页中间目录项是不重要的。页中间目录仅含有一个指向下属页表的目录项。所以，页中间目录项只是页全局目录中的一项而已。然而当处理页表时，创建一个页表项可能很复杂，因为包含页表项的那个页表可能就不存在。在这样的情况下，有必要分配一个新页框，把它填写为0，并把这个表项加入。

如果PAE被激活，内核使用三级页表。当内核创建一个新的页全局目录时，同时也分配四个相应的页中间目录;只有当父页全局目录被释放时，这四个页中间目录才得以释放。

当使用两级或三级分页时，页上级目录项总是被映射为页全局目录中的一个单独项。

| 函数名称                            | 说明                                       |
| ------------------------------- | ---------------------------------------- |
| pgd_alloc(mm)                   | 分配一个新的页全局目录。如果PAE被激活，它还分配3个对应用户态线性地址的子页中间目录。mm在x86体系结构上被忽略 |
| pgd_free(pgd)                   | 释放页全局目录中地址为pgd的项。如果PAE被激活，它还将释放用户态线性地址对应的三个页中间目录 |
| pud_alloc(mm,pgd,addr)          | 在两级或三级分页系统下，这个函数什么也不做:它仅仅返回页全局目录项pgd的线性地址 |
| pud_free(x)                     | 在两级或三级分页系统下，这个宏什么也不做                     |
| pmd_alloc(mm,pud,addr)          | 定义这个函数以使普通三级分页系统可以为线性地址addr分配一个新的页中间目录。如果PAE未被激活，这个函数只是返回输入参数pud的值，也就是说，返回页全局目录中目录项的地址。如果PAE被激活，该函数返回线性地址addr对应的页 |
| pmd_free(x)                     | 该函数什么也不做，因为页中间目录的分配和释放是随同它们的父全局目录一同进行的   |
| pte_alloc_map(mm,pmd,addr)      | 接收页中间目录项的地址pmd和线性地址addr作为参数，并返回与addr对应的页表项的地址。如果页中间目录项为空，该函数通过调用函数pte_alloc_one()分配一个新页表。如果分配了一个新页表，addr对应的项就被创建，同时User/Supervisor标志被设置为1。如果页表被保存在高端内存，贝内核建立一个临时内核映射，并用pte_unmap对它进行释放 |
| pte_alloc_kernel(mm,pmd,addr)   | 如果与地址addr相关的页中间目录项pmd为空，该函数分配一个新页表。然后返回与addr相关的页表项的线性地址。该函数仅被主内核页表使用 |
| pte_free(pte)                   | 释放与页描述符指针pte相关的页表                        |
| pte_free_kernel(pte)            | 等价于pte_free()，但由主内核页表使用                  |
| clear_page_range(mmu,start,end) | 从线性地址start到end通过反复释放页表和清除页中间目录项来清除进程页表的内容 |

#### 物理内存布局

可参考   [地址空间布局](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html)

在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。

内核将下列页框记为保留：

- 在不可用的物理地址范围内的页框。
- 含有内核代码和已初始化的数据结构的页框。

保留页框中的页绝不能被动态分配或交换到磁盘上。

一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小干3MB的RAM中。

为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如:

- 页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。因此，很多膝上型电脑的BIOS甚至在系统初始化后还将数据写到该页框。
- 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。
- 第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。

在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。

随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。

| 开始          | 结束           | 类型        |
| ----------- | ------------ | --------- |
| 0x0000 0000 | 0x0009 ffff  | Usable    |
| 0x000f 0000 | 0x000f ffff  | Reserved  |
| 0x0010 0000 | 0x07fe ffff  | Usable    |
| 0x07ff 0000 | 0x07ff 2ffff | ACPI data |
| 0x07ff 3000 | 0x07ff ffff  | ACPI NVS  |
| 0xffff 0000 | 0xffff ffff  | Reserved  |

上表显示了具有128MB RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。

内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局，这些变量如下表所示。

| 变量名称            | 说明                        |
| --------------- | ------------------------- |
| num_physpages   | 最高可用页框的页框号                |
| totalram_pages  | 可用页框的总数量                  |
| min_low_pfn     | RAM中在内核映像后第一个可用页框的页框号     |
| max_pfn         | 最后一个可用页框的页框号              |
| max_low_pfn     | 被内核直接映射的最后一个页框的页框号（低地址内存） |
| totalhigh_pages | 内核非直接映射的页框总数（高地址内存）       |
| highstart_pfn   | 内核非直接映射的第一个页框的页框号         |
| highend_pfn     | 内核非直接映射的最后一个页框的页框号        |

为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM：

![Linux2.6的前768个页框（3MB）.jpg](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux2.6%E7%9A%84%E5%89%8D768%E4%B8%AA%E9%A1%B5%E6%A1%86%EF%BC%883MB%EF%BC%89.jpg?raw=true)

符号\_text对应于物理地址0x0010 0000，表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号\_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在\_etext后开始，在\_edata处结束。紧接着是未初始化的数据并以\_end结束。

图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。

#### 进程页表

进程的线性地址空间分成两部分：

- 从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。
- 从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。

进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。

宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。

页全局目录的第一部分表项映射的线性地址小于0xc000 0000(在PAE未启用时是前768项，PAE启用时是前3项)，具体大小依赖于特定进程。相反，剩余的表项对所有进程来说都应该是相同的，它们等于主内核页全局目录的相应表项。

#### 内核页表

内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。

内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。

第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。

第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。

#### 临时内核页表

临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。我们不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。

临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。

分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。

内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化：

- 0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。
- 把这四个项中的Present、Read/Write和User/Supervisor标志置位。
- 把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。

汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段：

```c
movl $swapper_pg_dir-0xc0000000,%eax
movl %eax,%cr3		/*设置页表指针*/
movl %cr0,%eax
orl $0x80000000,%eax
movl %eax,%cr0		/*设置分页(PG)位“/
```

#### 当RAM小于896MB时的最终内核页表

由内核页表所提供的最终映射必须把从0xc0000000开始的线性地址转化为从0开始的物理地址。

宏\_\_pa用于把从PAGE_OFFSET开始的线性地址转换成相应的物理地址，而宏\_\_va做相反的转化。

主内核页全局目录仍然保存在swapper_pg_dir变量中。它由paging_init()函数初始化。该函数进行如下操作：

1. 调用pagetable_init()适当地建立页表项。
2. 把swapper_pg_dir的物理地址写入cr3控制寄存器中。
3. 如果CPU支持PAE并且如果内核编译时支持PAE，则将cr4控制寄存器的PAE标志置位。
4. 调用\_\_flush_tlb_all()使TLB的所有项无效。

pagetable_init()执行的操作既依赖于现有RAM的容量，也依赖于CPU模型。让我们从最简单的情况开始。我们的计算机有小于896MB(1024-128,128MB留给其他映射)的RAM, 32位物理地址足以对所有可用RAM进行寻址，因而没有必要激活PAE机制。
swapper_pg_dir页全局目录由如下等价的循环重新初始化：

```c
pgd = swapper_pg_dir + pgd_index(PAGE_OFFSET);	/*768*/
phys_addr = 0x00000000;
while(phys_addr < (max_low_pfn * PAGE_SIZE))
{
    pmd = one_md_table_init(pgd);	/*返回pgd*/
  	set_pmd(pmd, __pmd(phys_addr | pgprot_val(__pgprot(0x1e3))));
  /*0x1e3 == Present,Accessed,Dirty,Read/Write,Page Size,Global*/
  	phys_addr += PTRS_PER_PTE * PAGE_SIZE;	/*0X400000*/
  	++pgd;
}
```

我们假定CPU是支持4MB页和“全局(global)" TLB表项的最新x86微处理器。注意如果页全局目录项对应的是0xc0000000之上的线性地址，则把所有这些项的User/Supervisor标志清0，由此拒绝用户态进程访问内核地址空间。还要注意Page Size被置位使得内核可以通过使用大型页来对RAM进行寻址(“扩展分页”)。

由startup_32()函数创建的物理内存前8MB的恒等映射用来完成内核的初始化阶段。当这种映射不再必要时，内核调用zap_low_mappings()函数清除对应的页表项。

实际上，这种描述并未说明全部事实。我们将在后面“固定映射的线性地址”一节看到，内核也调整与“固定映射的线性地址”对应的页表项。

#### 当RAM大小在896MB—4096MB时的最终内核页表

在这种情况下，并不把RAM全部映射到内核地址空间。Linux在初始化阶段可以做的最好的事是把一个具有896MB的RAM窗口(window)映射到内核线性地址空间。如果一个程序需要对现有RAM的其余部分寻址，那就必须把某些其他的线性地址间隔映射到所需的RAM。这意味着修改某些页表项的值。将在以后（L-B：第八章 内存管理）讨论这种动态重映射是如何进行的。

内核使用与前一种情况相同的代码来初始化页全局目录。

#### 当RAM大于4096MB时的最终内核页表

现在考虑RAM大于4GB计算机的内核页表初始化;更确切地说，处理以下发生的情况：

- CPU模型支持物理地址扩展(PAE)
- RAM容量大于4GB
- 内核以PAE支持来编译

尽管PAE处理36位物理地址，但是线性地址依然是32位地址。如前所述，Linux映射一个896MB的RAM窗口到内核线性地址空间，剩余RAM留着不映射，并由动态重映射来处理，（L-B：第八章 内存管理）将对此进行描述。与前一种情况的主要差异是使用三级分页模型，因此页全局目录按以下循环代码来初始化：

```c
pgd_idx = pgd_index(PAGE_OFFSET);	/* 3 */
for(i = 0; i < pgd_idx; i++)
    set_pgd(swapper_pg_dir + i, __pgd(__pa(empty_zero_page) + 0x001));		/* 0x001 == Present */
pgd = swapper_pg_dir + pgd_idx;
phys_addr = 0x00000000;
for(; i < PTRS_PER_PGD; ++i, ++pgd)
{
    pmd = (pmd_t *)alloc_bootmem_low_pages(PAGE_SIZE);
  	set_pgd(pgd, __pgd(__pa(pmd) | 0x001));
  	if(phys_addr < max_low_pfn * PAGE_SIZE)
      	for(j = 0; j < PTRS_PER_PMD && phys_addr < max_low_pfn * PAGE_SIZE; ++j)
        {
            set_pmd(pmd, __pmd(phys_addr | pgprot_val(__pgprot(0x1e3))));
          	/*0x1e3 == Present,Accessed,Dirty,Read/Write,Page Size,Global*/
            phys_addr += PTRS_PER_PTE * PAGE_SIZE;	/* 0x200000 */
        }
}
swapper_pg_dir[0] = swapper_pg_dir(pgd_idx);
```

页全局目录中的前三项与用户线性地址空间相对应，内核用一个空页(empty_zeropage)的地址对这三项进行初始化。第四项用页中间目录(pmd)的地址初始化，该页中间目录是通过调用alloc_bootmem_low_pages()分配的。页中间目录中的前448项(有512项，但后64项留给非连续内存分配)用RAM前896MB的物理地址填充。

注意，支持PAE的所有CPU模型也支持大型2MB页和全局页。正如前一种情况一样，只要可能，Linux使用大型页来减少页表数。

然后页全局目录的第四项被拷贝到第一项中，这样好为线性地址空间的前896MB中的低物理内存映射作镜像。为了完成对SMP系统的初始化，这个映射是必需的:当这个映射不再必要时，内核通过调用zap_low_mappings()函数来清除对应的页表项，正如先前的情况一样。

#### 固定映射的线性地址

内核线性地址第四个GB的初始部分映射系统的物理内存。但是，至少128MB的线性地址总是留作他用，因为内核使用这些线性地址实现非连续性内存分配和固定映射的线性地址。

非连续内存分配仅仅是动态分配和释放内存页的一种特殊方式。

固定映射的线性地址（fix-mapped linear address）基本上是一种类似于0xffff c000这样的常量线性地址，其对应的物理地址不必等于线性地址减去0xc000 0000，而是可以以任意方式建立。因此，每个固定映射的线性地址都映射一个物理内存的页框。之后会看到，内核使用固定映射的线性地址来代替指针变量，因为这些指针变量的值从不改变。

固定映射的线性地址概念上类似于对RAM前896MB映射的线性地址。不过，固定映射的线性地址可以映射任何物理地址，而由第4GB初始部分的线性地址所建立的映射是线性的（线性地址X 映射物理地址X-PAGE_OFFSET）。
就指针变量而言，固定映射的线性地址更有效。事实上，间接引用一个指针变量比间接引用一个立即常量地址要多一次内存访问。此外，在间接引用一个指针变量之前对其值进行检查是一个良好的编程习惯；相反，对一个常量线性地址的检查则是没有必要的。

每个固定映射的线性地址都由定义于enum fixed_addresses的数据结构中的整型索引来表示：

```c
enum fixed_addresses {
#ifdef CONFIG_X86_32
	FIX_HOLE,
	FIX_VDSO,
#else
	VSYSCALL_LAST_PAGE,
	VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE
			    + ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
	VSYSCALL_HPET,
#endif
	FIX_DBGP_BASE,
	FIX_EARLYCON_MEM_BASE,
#ifdef CONFIG_PROVIDE_OHCI1394_DMA_INIT
	FIX_OHCI1394_BASE,
#endif
#ifdef CONFIG_X86_LOCAL_APIC
	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
#endif
#ifdef CONFIG_X86_IO_APIC
	FIX_IO_APIC_BASE_0,
	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS - 1,
#endif
#ifdef CONFIG_X86_VISWS_APIC
	FIX_CO_CPU,	/* Cobalt timer */
	FIX_CO_APIC,	/* Cobalt APIC Redirection Table */
	FIX_LI_PCIA,	/* Lithium PCI Bridge A */
	FIX_LI_PCIB,	/* Lithium PCI Bridge B */
#endif
#ifdef CONFIG_X86_F00F_BUG
	FIX_F00F_IDT,	/* Virtual mapping for IDT */
#endif
#ifdef CONFIG_X86_CYCLONE_TIMER
	FIX_CYCLONE_TIMER, /*cyclone timer register*/
#endif
#ifdef CONFIG_X86_32
	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
#ifdef CONFIG_PCI_MMCONFIG
	FIX_PCIE_MCFG,
#endif
#endif
#ifdef CONFIG_PARAVIRT
	FIX_PARAVIRT_BOOTMAP,
#endif
	FIX_TEXT_POKE1,	/* reserve 2 pages for text_poke() */
	FIX_TEXT_POKE0, /* first page is last, because allocation is backward */
	__end_of_permanent_fixed_addresses,
	/*
	 * 256 temporary boot-time mappings, used by early_ioremap(),
	 * before ioremap() is functional.
	 *
	 * If necessary we round it up to the next 256 pages boundary so
	 * that we can have a single pgd entry and a single pte table:
	 */
#define NR_FIX_BTMAPS		64
#define FIX_BTMAPS_SLOTS	4
#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
	FIX_BTMAP_END =
	 (__end_of_permanent_fixed_addresses ^
	  (__end_of_permanent_fixed_addresses + TOTAL_FIX_BTMAPS - 1)) &
	 -PTRS_PER_PTE
	 ? __end_of_permanent_fixed_addresses + TOTAL_FIX_BTMAPS -
	   (__end_of_permanent_fixed_addresses & (TOTAL_FIX_BTMAPS - 1))
	 : __end_of_permanent_fixed_addresses,
	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - 1,
#ifdef CONFIG_X86_32
	FIX_WP_TEST,
#endif
#ifdef CONFIG_INTEL_TXT
	FIX_TBOOT_BASE,
#endif
	__end_of_fixed_addresses
};
```

每个固定映射的线性地址都存放在线性地址第四个GB的末端。fix_to_virt()函数计算从给定索引开始的常量线性地址：

```c
static __always_inline unsigned long fix_to_virt(const unsigned int idx)
{
	/*
	 * this branch gets completely eliminated after inlining,
	 * except when someone tries to use fixaddr indices in an
	 * illegal way. (such as mixing up address types or using
	 * out-of-range indices).
	 *
	 * If it doesn't get removed, the linker will complain
	 * loudly with a reasonably clear error message..
	 */
	if (idx >= __end_of_fixed_addresses)
		__this_fixmap_does_not_exist();

	return __fix_to_virt(idx);
}
```

假定某个内核函数调用fix_to_virt(FIX_IO_APIC_BASE\_0)。因为该函数声明为"\_\_always_inline"，所以C编译程序不调用fix_to_virt()，而仅仅把它的代码插入到调用函数中。此外，运行时从不对这个索引值进行检查。事实上，FIX_IO_APIC_BASE_0是个等于3的常量，因此编译程序可以去掉if语句，因为它的条件在编译时为假。相反，如果条件为真，或者参数不是一个常量，则编译程序在连接阶段产生一个错误，因为符号__this_fixmap_does_not_exist在别处没有定义。最后，编译程序计算0xffff f000-(3 << PAGE_SHIFT)，并用常量线性地址0xfff c000代替fix_to_virt()函数调用。

为了把一个物理地址与固定映射的线性地址关联起来，内核使用set_fixmap(idx,phys)和set_fixmap_nocache(idx,phys)宏。这两个函数都把fix_to_virt(idx)线性地址对应的一个页表项初始化为物理地址phys；不过，第二个函数也把页表项的PCD标志置位，因此，当访问这个页框中的数据时禁用硬件高速缓存。反过来，clear_fixmap(idx)用来撤消固定映射线性地址idx和物理地址之间的连接。

#### 处理硬件高速缓存和TLB

硬件高速缓存是通过高速缓存行(cache line)寻址的。L1_CACHE_BYTES宏产生以字节为单位的高速缓存行的大小。在早于Pentium 4的Intel模型中，这个宏产生的值为32;在Pentium 4上，它产生的值为128。

- 为了使高速缓存的命中率达到最优化，内核在下列决策中考虑体系结构：
  一个数据结构中最常使用的字段放在该数据结构内的低偏移部分，以便它们能够处于高速缓存的同一行中。
- 当为一大组数据结构分配空间时，内核试图把它们都存放在内存中，以便所有高速缓存行按同一方式使用。

x86微处理器自动处理高速缓存的同步，所以应用于这种处理器的Linux内核并不处理任何硬件高速缓存的刷新。不过内核却为不能同步高速缓存的处理器提供了高速缓存刷新接口。

处理器不能自动同步它们自己的TLB高速缓存，因为决定线性地址和物理地址之间映射何时不再有效的是内核，而不是硬件。

Linux 2.6提供了几种在合适时机应当运用的TLB刷新方法，这取决于页表更换的类型。

| 方法名称                   | 说明                      | 典型的应用时机        |
| ---------------------- | ----------------------- | -------------- |
| flush_tlb_all          | 刷新所有TLB表项               | 改变内核页表项时       |
| flush_tlb_kernel_range | 刷新给定线性地址范围内的所有TLB表项     | 更换一个范围内的内核页表项时 |
| flush_tlb              | 刷新当前进程拥有的非全局页相关的所有TLB表项 | 执行进程切换时        |
| flush_tlb_mm           | 刷新指定进程拥有的非全局页相关的所有TLB表项 | 创建一个新的子进程时     |
| flush_tlb_range        | 刷新指定进程的线性地址间隔对应的TLB表项   | 释放某个进程的线性地址间隔时 |
| flush_tlb_pgtables     | 刷新指定进程中特定的相临页表集相关的TLB表项 | 释放进程的一些页表时     |
| flush_tlb_page         | 刷新指定进程中单个页表项相关的TLB表项    | 处理缺页异常时        |

尽管普通Linux内核提供了丰富的TLB方法，但通常每个微处理器都提供了更受限制的一组使TLB无效的汇编语言指令。在这个方面，一个更为灵活的硬件平台就是Sun的U1traSPARC。与之相比，Intel微处理器只提供了两种使TLB无效的技术：

- 在向cr3寄存器写入值时所有Pentium处理器自动刷新相对于非全局页的TLB表项。
- 在Pentium Pro及以后的处理器中，invlpg汇编语言指令使映射指定线性地址的单个TLB表项无效。

下表列出了采用这种硬件技术的Linux宏；这些宏是实现独立于系统的方法（上表）的基本要素。

| 宏名称                      | 描述                                       | 使用对象                                   |
| ------------------------ | ---------------------------------------- | -------------------------------------- |
| __flush_tlb()            | 将cr3寄存器的当前值重新写回cr3                       | flush_tlb，flush_tlb_mm，flush_tlb_range |
| __flush_tlb_global()     | 通过清除cr4的PGE禁用全局页，将cr3寄存器的当前值重新写回cr3，并在此设置PGE标志 | flush_tlb_all，flush_tlb_kernel_range   |
| __flush_tlb_single(addr) | 以addr为参数执行invlpg汇编语言指令                   | flush_tlb_page                         |

上表中没有flush tlb_pgtables方法：在x86系统中，当页表与父页表解除链接时什么也不需要做，所以实现这个方法的函数为空。

独立于体系结构的使TLB无效的方法非常简单地扩展到了多处理器系统上。在一个CPU上运行的函数发送一个处理器间中断给其他的CPU来强制它们执行适当的函数使TLB无效。

一般来说，任何进程切换都会暗示着更换活动页表集。相对于过期页表，本地TLB表项必须被刷新；这个过程在内核把新的页全局目录的地址写入cr3控制寄存器时会自动完成。不过内核在下列情况下将避免TLB被刷新：

- 当两个使用相同页表集的普通进程之间执行进程切换时。
- 当在一个普通进程和一个内核线程间执行进程切换时。（内核线程无自己的页表集，使用上一个普通进程的页表集）

除了进程切换以外，还有其他几种情况下内核需要刷新TLB中的一些表项。例如，当内核为某个用户态进程分配页框并将它的物理地址存入页表项时，它必须刷新与相应线性地址对应的任何本地TLB表项。在多处理器系统中，如果有多个CPU在使用相同的页表集，那么内核还必须刷新这些CPU上使用相同页表集的TLB表项。

为了避免多处理器系统上无用的TLB刷新，内核使用一种叫做懒惰TLB (lazy TLB)模式的技术。其基本思想是，如果几个CPU正在使用相同的页表，而且必须对这些CPU上的一个TLB表项刷新，那么，在某些情况下，正在运行内核线程的那些CPU上的刷新就可以延迟。

事实上，每个内核线程并不拥有自己的页表集，它使用一个普通进程的的页表集。不过，没有必要使一个用户态线性地址对应的TLB表项无效，因为内核线程不访问内核态地址空间。（flush_tlb_all方法不使用懒惰TLB模式机制）

当某个CPU开始运行一个内核线程时，内核把它置为懒惰TLB模式。当发出清除TLB表项的请求时，处于懒惰TLB模式的每个CPU都不刷新相应的表项。但是，CPU记住它的当前进程正运行在一组页表上，而这组页表的TLB表项对用户态地址是无效的。只要处于懒惰TLB模式的CPU用一个不同的页表集切换到一个普通进程，硬件就自动刷新TLB表项，同时内核把CPU设置为非懒惰TLB模式。然而，如果处于懒惰TLB模式的CPU切换到的进程与刚才运行的内核线程拥有相同的页表集，那么，任何使TLB无效的延迟操作必须由内核有效地实施；这种使TLB无效的“懒惰”操作可以通过刷新CPU的所有非全局TLB项来有效地获取。

为了实现懒惰TLB模式，需要一些额外的数据结构。cpu_tlbstate变量是一个具有NR_CPUS个结构的静态数组，这个结构有两个字段，一个是指向当前进程内存描述符的active_ mm字段，一个是具有两个状态值的state字段:TLBSTATE_ OK(非懒惰TLB模式)或TLBSTATE_LAZY(懒惰TLB模式)。此外，每个内存描述符中包含一个cpu_vm_mask字段，该字段存放的是CPU(这些CPU将要接收与TLB刷新相关的处理器间中断)下标；只有当内存描述符属于当前运行的一个进程时这个字段才有意义。

当一个CPU开始执行内核线程时、内核把该CPU的cpu_tlbstate元素的state字段置为TLBSTATE_LAZY。此外，活动(active)内存描述符的cpu_vm_mask字段存放系统中所有CPU(包括进入懒惰TLB模式的CPU)的下标。对于与给定页表集相关的所有CPU的TLB表项，当另外一个CPU想使这些表项无效时，该CPU就把一个处理器间中断发送给下标处于对应内存描述符的cpu_vm_mask字段中的那些CPU。

当CPU接受到一个与TLB刷新相关的处理器间中断，并验证它影响了其当前进程的页表集时，它就检查它的cpu_tlbstate元素的state字段是否等于TLBSTATE_LAZY；如果等于，内核就拒绝使TLB表项无效，并从内存描述符的cpu_vm_mask字段删除该CPU下标。这有两种结果：

- 只要CPU还处于懒惰TLB模式，它将不接受其他与TLB刷新相关的处理器间中断。
- 如果CPU切换到另一个进程，而这个进程与刚被替换的内核线程使用相同的页表集，那么内核调用\_\_flush_tlb()使该CPU的所有非全局TLB表项无效。

##  第3章 进程

## 第4章 中断与异常

## 第5章 内核同步

## 第6章 定时测量

## 第7章 进程调度

## 第8章 内存管理

## 第9章 进程地址空间

## 第10章 系统调用

## 第11章 信号

## 第12章 虚拟文件系统

## 第13章 I/O体系结构和设备驱动程序

## 第14章 块设备驱动程序

## 第15章 页高速缓存

## 第16章 访问文件

## 第17章 回收页框

## 第18章 Ext2和Ext3文件系统

## 第19章 进程通信

## 第20章 程序的执行

## 附录一 系统启动

## 附录二 模块